<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Stat110 - Introduction to Probability代码的R语言与Python实现</title>
      <link href="/2020/04/07/stat110/"/>
      <url>/2020/04/07/stat110/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这篇文章主要是用于记录将《Introduction to Probability》第一版一书中的R代码向Python进行翻译转换，在更新中。</p><p>资源链接：<a href="http://stat110.net" target="_blank" rel="noopener">http://stat110.net</a></p><h1 id="Chapter-01"><a href="#Chapter-01" class="headerlink" title="Chapter 01"></a>Chapter 01</h1><p>对应原文1.8内容。</p><p>国内用R的话建议直接使用清华镜像下载R语言：<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/CRAN/</a></p><p>R语言在科学计算上的确有很多优势，但是学习起来学习曲线比较陡峭，不太适合新手。</p><p>我用惯了Python，想要同时把他们两都操作一下熟悉熟悉。</p><p>以后的代码对比都以下面的形式或者表格形式来展现。</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python">v <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将v定义为一组向量[3,1,4,1,5,9]</span></code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">v <- c(3,1,4,1,5,9) # 将v定义为一组向量(3,1,4,1,5,9),c代表concatenate</code></pre><p>在Python里面此处用Numpy的数组做向量。与Python不同，R语言是建立在向量之上的，就算是简单的 <code>n &lt;- 100</code> 都被R视为一个长度为1的向量。</p><p>当然在R里面稍有不同的是，”=”与”&lt;-“使用上稍有不同，在函数调用中，func(x=1)与func(x&lt;-1)是有区别的，前者调用完后变量x不会被保留，而后者会在工作区里保留变量x=1。</p><p>R与Python不同的地方还是有挺多的：</p><table><thead><tr><th>Python</th><th>R</th><th>效果</th></tr></thead><tbody><tr><td>sum(v)</td><td>sum(v)</td><td>求和</td></tr><tr><td>max(v)</td><td>max(v)</td><td>求最大值</td></tr><tr><td>min(v)</td><td>min(v)</td><td>求最小值</td></tr><tr><td>len(v)</td><td>length(v)</td><td>获得长度</td></tr><tr><td>range(m,n+1)</td><td>m:n</td><td>m,m+1,…n-1,n</td></tr></tbody></table><p>在元素获取上，两者区别还是挺大的，最大区别还是从0还是1开始数：</p><table><thead><tr><th>Python</th><th>R</th><th style="text-align:left">输出</th></tr></thead><tbody><tr><td>v[0]</td><td>v[1]</td><td style="text-align:left">3</td></tr><tr><td>？</td><td>v[-(2:4)]</td><td style="text-align:left">1 5 9</td></tr><tr><td>v[[0,2,4]]</td><td>v[c(1,3,5)]</td><td style="text-align:left">[3,4,5] / 3 4 5</td></tr><tr><td>[x**(-2) for x in range(1,101)]</td><td>1/(1:100)^2</td><td style="text-align:left">$($${1} \over {1^2}$$,$${1} \over {2^2}$$,…,$${1} \over {100^2}$$)$</td></tr></tbody></table><h2 id="阶乘与二项式"><a href="#阶乘与二项式" class="headerlink" title="阶乘与二项式"></a>阶乘与二项式</h2><p>在本来并不用于计算的Python中，运算这种需要调用别的库，例如阶乘：</p><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> mathmath<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span>n<span class="token punctuation">)</span></code></pre><p><strong>R：</strong></p><pre><code>facotrial(n)</code></pre><p>同样的也有像二项式，一般Python图方便会直接自己写一个函数，不过实在要调用也是可以的。</p><p><strong>Python</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> scipy<span class="token punctuation">.</span>special <span class="token keyword">import</span> combcomb<span class="token punctuation">(</span>n<span class="token punctuation">,</span>k<span class="token punctuation">)</span></code></pre><p><strong>R：</strong></p><pre><code>choose(n,k)</code></pre><p>R相较之下真的太方便了。此外R还有lchoose(n,k)，lfactorial(n)用来运算log值，方便进行乘法转换加法。</p><h2 id="取样模拟"><a href="#取样模拟" class="headerlink" title="取样模拟"></a>取样模拟</h2><p>这方面上不同的更多了，直接上表格吧。</p><table><thead><tr><th>Python</th><th>R</th><th>效果</th></tr></thead><tbody><tr><td>np.random.choice(range(1,n+1),size=k,replace=False)</td><td>sample(n,k)</td><td>从1-n中不放回抽样k次</td></tr><tr><td>np.random.choice(range(1,n+1),size=k)</td><td>sample(n,k,replace=True)</td><td>从1-n中有放回抽样k次</td></tr><tr><td>np.random.choice([‘a’,’b’,…,’z’]),size=k,,replace=False)</td><td>sample(letters,k) #letters是R自带的26个小写字母表数组</td><td>从26个字符中取不重复地取字母组成k字符单词</td></tr><tr><td>#大概在SciPy里有，还是学了再补充吧。</td><td>sample(4, 3, replace=TRUE, prob=c(0.1,0.2,0.3,0.4))</td><td>1-4的概率分别为0.1,0.2,0.3,0.4</td></tr></tbody></table><h2 id="de-Montmort‘s-配对问题"><a href="#de-Montmort‘s-配对问题" class="headerlink" title="de Montmort‘s 配对问题"></a>de Montmort‘s 配对问题</h2><p>de Montmort’s配对问题指的是一堆卡片标有1-n的数字，打乱后一张一张的掀开，第k次掀开的若对应的数字正好为k，那么则视为成功，求的是整套卡片翻完的至少成功一次的概率。</p><p>单纯的运算需要运用Inclusion-exclusion公式：</p><p><img src="/2020/04/07/stat110/1-1.png" alt="de Montmort‘s"></p><p>而在代码里我们可以做simulation模拟。</p><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">100</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>replace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token operator">==</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> r<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">:</span>        count<span class="token operator">+=</span><span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>count<span class="token operator">/</span><span class="token number">10</span><span class="token operator">**</span><span class="token number">4</span><span class="token punctuation">)</span></code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">n <- 100r <- replicate(10^4,sum(sample(n)==(1:n))) # 重复10^4次，计算n个不重复取样与1:n的相同个数总数sum(r>=1)/10^4</code></pre><p>R是真的简短很多…不过说真的，python相比之下更加友好。</p><h2 id="生日问题"><a href="#生日问题" class="headerlink" title="生日问题"></a>生日问题</h2><p>对于概率计算，Python，所幸numpy也支持prod。</p><p><strong>Python：</strong></p><pre class=" language-python"><code class="language-python"><span class="token number">1</span><span class="token operator">-</span>np<span class="token punctuation">.</span>prod<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">365</span><span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">365</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">365</span><span class="token operator">**</span>k</code></pre><p><strong>R的话有两种方式：</strong></p><pre class=" language-R"><code class="language-R">1-prod((365-k+1):365)/365^k # 1.直接计算pbirthday(k) # 2.使用内置的函数</code></pre><p>还挺犯规的，生日问题都内置了。而且R还能用<code>qbirthday(n)</code>来计算达到n概率两人以上相同生日所需要的人数。</p><p>而且对于这两个函数，能加上coincident参数来指定特定多少人同一天生日，就不做示范了。</p><p>生日问题的模拟的话是这样：</p><p><strong>Python：</strong></p><pre><code>count = 0for i in range(10**4):    if Counter(np.random.choice(range(365),23)).most_common(1)[0][1]&gt;1:        count += 1print(count/10**4)</code></pre><p><strong>R：</strong></p><pre class=" language-R"><code class="language-R">r <- replicate(10^4, max(tabulate(sample(1:365,23,replace=TRUE)))) # 重复10^4次，计算23次从365个数重复取样取得相同次数最多的个数sum(r>=2)/10^4</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Probability </tag>
            
            <tag> R </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一点点开始生成对抗网络</title>
      <link href="/2019/03/21/gan/"/>
      <url>/2019/03/21/gan/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于各种由TLC变成AC的解决</title>
      <link href="/2018/12/24/tlesolution/"/>
      <url>/2018/12/24/tlesolution/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>太久没写博了以至于快要忘记了这东西，因为太忙了，不过偶尔还是会更一更吧。<br>遇到过好多弱智题明明都知道该怎么做但是硬是TLE，总结一下类型吧。</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>预处理很多地方都用得到，一般都用在那种递推问题上（就是那种f(n)需要先求f(n-1)之类的），这种情况你要是每测试一个值都重新求一次就很麻烦，不如直接预处理一遍把从1~n（看题目取n的大小）的答案获取存数组里，然后便可以直接输出答案。<br><a href="&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1250&quot;">Hat’s Fibonacci</a></p><p>预处理水题，大数，当看例题就好。</p><pre><code>import java.math.BigInteger;import java.util.Scanner;/** * @class: hdu1250 * @author: Chitose * @date: 2018/12/24 * @description: */public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        BigInteger fib[] = new BigInteger[10000];        fib[1] = fib[2] = fib[3] = fib[4] = BigInteger.ONE;        for(int i = 5 ; i &lt; 10000 ; i++){            fib[i] = fib[i-1].add(fib[i-2]).add(fib[i-3]).add(fib[i-4]);        }        while(sc.hasNext()){            System.out.println(fib[sc.nextInt()]);        }    }}</code></pre><h1 id="保存计算值"><a href="#保存计算值" class="headerlink" title="保存计算值"></a>保存计算值</h1><p>这一招甚至可以用在任何题当中，将自己每一次测试的值保存下来，防止有重复的测试用例。（当然那种测试用例很大的输出小的可能就不太适用了。）<br><a href="&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2553&quot;">N皇后问题</a></p><p>经典的n皇后模板题简单DFS，但不保存每次的值就会TLE：</p><pre><code>import java.util.HashMap;import java.util.Map;import java.util.Scanner;/** * @class: hdu2553 * @author: Chitose * @date: 2018/12/24 * @description: */public class Main {    static int n;    private static int ans;    private static int[] cols;//按行来记录皇后，那么用一个一维数组就可以记录了    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        Map&lt;Integer,Integer&gt; map = new HashMap();        while((n=sc.nextInt())!=0){            if(map.containsKey(n))                System.out.println(map.get(n));            else {                ans = 0;                cols = new int[n];                dfs(0);                System.out.println(ans);                map.put(n, ans);            }        }    }    static void dfs(int used){        if(used == n)   ans++;        else for(int i = 0 ; i &lt; n ; i++){            cols[used] = i;            if(ok(used))                dfs(used+1);        }    }    static boolean ok(int row){        for(int i = 0 ; i &lt; row ; i++){            if(cols[row] == cols[i] || row - cols[row] == i - cols[i] || row + cols[row] == i + cols[i])    //这里有技巧，寻找是否同一对角线上的话只需要找截距相同的点就可以了，斜率都是1或-1                return false;        }        return true;    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度搜索、广度搜索</title>
      <link href="/2018/12/03/dfs-bfs/"/>
      <url>/2018/12/03/dfs-bfs/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="字母列举例题"><a href="#字母列举例题" class="headerlink" title="字母列举例题"></a>字母列举例题</h1><font color="#0099ff"><strong>Problem description</strong></font><blockquote><p>概率论老师：听懂了么？<br>大家：。。。<br>概率论是门有趣的学科，但我不想凭概率挂科，是时候认真看看书了<br>书里有一道这样的题目：</p></blockquote><blockquote><p>一俱乐部有5名一年级学生，2名二年级学生，3名三年级学生，2名四年级学生。<br>在其中任选5名学生，求一、二、三、四年级学生均包含在内的概率。<br>概率论是个细活，不过我比较粗心，经常漏掉几种情况而算错<br>现在我想让你编个程序列举出所有符合要求（各年级学生均包含在内）的情况</p></blockquote><font color="#0099ff"><strong>Input</strong></font><blockquote><p>首先输入一个t表示有t组样例<br>每组样例有两行输入<br>第一行输入N（1&lt;=N&lt;=6）表示有N个年级，紧接着按顺序输入从1到N每个年级对应的学生数量m（1&lt;m&lt;50）<br>第二行输入要抽选的学生人数n(N&lt;=n&lt;=总人数)</p></blockquote><font color="#0099ff"><strong>Output</strong></font><blockquote><p>用n代表一个属于n年级的学生<br>例如：1 2 3 4 4 代表1名一年级、1名二年级、一名三年级和两名4年级的学生的组合<br>对于每组样例，每种组合按年级顺序输出对应学生并用空格隔开（行尾没有多余空格），并按字典序输出所有可能的组合</p></blockquote><p><font color="#0099ff"><strong>Sample Input</strong></font></p><blockquote><p>2<br>4 5 2 3 2<br>5<br>1 4<br>2</p></blockquote><p><font color="#0099ff"><strong>Sample Output</strong></font></p><blockquote><p>1 1 2 3 4<br>1 2 2 3 4<br>1 2 3 3 4<br>1 2 3 4 4<br>1 1</p></blockquote><p><strong>简单DFS思路</strong><br>先从各年级取一个人，然后再DFS各年级的剩下的人，取出来全部后排序即可。<br>重点在于不能重复计算，所以要从小到大执行。</p><p>Java代码：</p><pre><code>import java.util.Arrays;import java.util.Scanner;public class Main {    static int grades;      //年级数    static int[] men;       //各年级的人数    static int num;         //总共需要的人数    static int[] dfs;       //用于存放选取出来的人    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        while(n--&gt;0){            grades = sc.nextInt();            men = new int[grades+1];            for(int i = 1 ; i &lt;= grades ; i++){                men[i] = sc.nextInt();            }            num = sc.nextInt();            dfs = new int[num+1];            for(int i = 1; i &lt;= grades ; i++){                dfs[i] = i;         //首先选好各年级一人满足题目条件            }            dfs(1);        }    }    static void dfs(int layer){        //出口：人数足够，将选好的人排序并输出        if(layer+grades&gt;num) {            int[] tmp = Arrays.copyOfRange(dfs, 0, num+1);            Arrays.sort(tmp);            for(int i = 1 ; i &lt;= num ; i++){                if(i!=num)                    System.out.print(tmp[i]+&quot; &quot;);                else                    System.out.print(tmp[i]);            }            System.out.println();        }else {            for (int i = 1; i &lt;= grades; i++) {            //判断条件：该年级还有人且当前位置的数不比要填的数大（保证不重复）                if (men[i]&gt; 1 &amp;&amp; (i&gt;=dfs[layer+grades-1] || layer==1)) {                    men[i]--;                    dfs[layer+grades] = i;                    dfs(layer + 1);                    men[i]++;                }            }        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>欧拉函数、费马小定理</title>
      <link href="/2018/11/19/eulerandfermet/"/>
      <url>/2018/11/19/eulerandfermet/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="HDU1098"><a href="#HDU1098" class="headerlink" title="HDU1098"></a>HDU1098</h1><p><a href="&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1098&quot;">Ignatius’s puzzle</a><br>（费马小定理）</p><p>f(x)=5<em>x^13+13</em>x^5+k<em>a</em>x转化成f(x)=(5<em>x^12+13</em>x^4+k<em>a)</em>x</p><p>从1~65开始数，倘若x%65!=0，则必须要里面的内容<strong>(5<em>x^12+13</em>x^4+k*a)%65=0</strong>，<br>那么分开来看：</p><p>左边的5<em>x^12本来就是5的倍数，根据费马小定理他被13整除的结果：<br>而  </em>x^(13-1)%13≡1<em>，<br>故  ** 5</em>x^12%13≡5 **。</p><p>中间的13<em>x^5本来就是13的倍数，根据费马小定理他被5整除的结果：<br>而  </em>x^(5-1)%5≡1<em>，<br>故  ** 13</em>x^5%5≡2 **。</p><p>那么对于最后的ka我们可以这样看：<br>当需要他被13整除的时候，左边已经有5了，那么这时候只需要<strong>ka%13==8</strong>；<br>当需要他被13整除的时候，中间已经有2了，那么这时候只需要<strong>ka%5==3</strong>；<br>满足这两个式子的a便是满足题意的a值</p><p>Java代码如下：</p><pre><code>import java.util.Scanner;public class hdu1098 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in) ;        while(sc.hasNext()){            int ans = -1;            int k = sc.nextInt();            for(int a = 1 ; a &lt;=65 ; a++){                if(k*a%5==2 &amp;&amp; k*a%13==8){                    ans = a;                    break;                }            }            if(ans&gt;0)                System.out.println(ans);            else                System.out.println(&quot;no&quot;);        }    }}</code></pre><h1 id="HDU2588"><a href="#HDU2588" class="headerlink" title="HDU2588"></a>HDU2588</h1><p><a href="&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2588&quot;">GCD</a><br>（欧拉函数）</p><p>这题真的好折腾啊…题目过于误导人去用gcd了（一用不是TLE就是MLE）<br>首先对于 gcd(x,n)=i ，<strong>x/i显然与n/i互斥</strong>（即gcd(x/i,n/i)=1)<br>那么<strong>求x/i的个数就相当于求x的个数了，</strong><br>而对于gcd(x,n)!=1的x，必然是n的约数，<br>所以只需要遍历i-&gt;[1,n]为n的约数的，求出各个与n/i互斥的x/i个数，<br>即使用欧拉函数——<strong>累计φ(n/i)</strong>的值即可。</p><p>但在这题有10^9的那么大的数，为了优化，就只遍历到sqrt(n)即可了，对于大于sqrt(n)的i，<br>因为每一次遍历得到的为n的约数的i，相应的也会同样有n的约数n/i（除去了i^2=n的情况，防止重复），<br>那么每一次遍历就是ans += φ(n/i) 和 ans += φ(n/(n/i))，<br>即<strong>ans += φ(n/i) 和ans += φ(i)</strong></p><p>Java代码如下：</p><pre><code>import java.util.Scanner;public class hdu2879 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int cases = sc.nextInt();        for(int i = 0 ; i &lt;cases; i++) {            int N = sc.nextInt();            int M = sc.nextInt();            int sum = 0;            for(int j =1 ; j &lt;= Math.sqrt(N) ; j++){                if(N%j == 0){                    if(j&gt;=M &amp;&amp; j!= Math.sqrt(N) ){                        sum += euler(N/j);                    }                    if(N/j &gt;= M){                        sum += euler(j);                    }                }            }            System.out.println(sum);        }    }    static int euler(int num){        int ans = 1;        for(int i = 2 ; i &lt;= num ;i++){            if(num%i==0){                ans *= (i-1);                num/=i;                while(num%i==0) {                    ans *= i;                    num /= i;                }            }        }        return ans;    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>I don&#39;t know</title>
      <link href="/2018/11/18/idk/"/>
      <url>/2018/11/18/idk/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>我在空间日志里写了一篇日志，记录一下当天还能支持着我活下去的事物吧。<br>他们可能简单的平凡无比，也是这样我才敢大声说出来。<br>“想食秋刀鱼。”<br>这样的心情也能支撑我有动力一点。<br>但是那篇日志真的几乎不怎么更新了，后面更新我想写下去的东西都过于晦涩或者说是…<br>像是想去死的理由。<br>“想逃离”、“想怀抱温柔的梦”、“想要退学”…<br>以至于很多我都不想再写出来了，因为那样根本已经不是“你为什么还活着？”的答复了。<br>但是我写不出来的时候，就像我一次次难以用面具shadow自己的时候，我也不愿意或者不会直接让任何人知道。<br>又或者我直接逃避这个问题，当一会儿行尸走肉。<br>但是我被拷问了，<br>可能是我这个行尸走肉都当不下去了，然后我便被拷问了：<br>“你明明不喜欢这个东西，为什么还要做下去呢？”<br>这句话可能是个初端吧。<br>当这句话穿过我的耳膜，我明白我摆不下去了。</p><p>我发现我所做过的好多好多并非我所喜爱的东西，<br>即便是为梦做铺垫的事物我页没有说有所坚持，<br>为这个那个事情所困扰，<br>然后到头来一无所成。<br>给自己搭的虚空楼筑一瞬间就要崩塌。<br>我浪费了多长时间在现在自己不需要的东西上，<br>又或者，<br>已经几乎每次都是才知道自己的“不足”，而在追逐的途中更加发现自己是“远远不足”<br>那我到底要花多久花多少精力我才完全知道自己不足之处，才知道自己该干什么呢？<br>后知后觉的迷子也开始问道自己了：<br>“我到底为什么还活着呢？”<br>“你们杀了我吧。”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vomit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态规划之背包问题</title>
      <link href="/2018/11/13/dps/"/>
      <url>/2018/11/13/dps/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="HDU2602"><a href="#HDU2602" class="headerlink" title="HDU2602"></a>HDU2602</h1><p><a href="&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2602&quot;">Bone Collector</a><br>解题思路：<br>交学费题。<br>一看就是01背包以为没什么难的，<br>一开始还懵了一直WA看题目条件还以为是大数才A不了，<br><strong>结果原来还有体积为0的东西</strong>。</p><pre><code>import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        while (n-- &gt; 0) {            int N = sc.nextInt();            int V = sc.nextInt();            int val[] = new int[N + 1];            int vol[] = new int[N + 1];            int dp[][] = new int[N + 1][V + 1];            for (int i = 1; i &lt;= N; i++) {                val[i] = sc.nextInt();            }            for (int i = 1; i &lt;= N; i++) {                vol[i] = sc.nextInt();            }            for(int i = 0 ; i &lt;= V ; i ++){                dp[0][i] = 0;            }            for (int i = 1; i &lt;= N; i++) {                for (int k = 0; k &lt;= V; k++) {                    if(k&gt;=vol[i]) {                        int a = dp[i - 1][k];                        int b = dp[i - 1][k - vol[i]]+(val[i]);                        dp[i][k] = a&gt;b?a:b;                    }else dp[i][k] = dp[i - 1][k];                }            }            System.out.println(dp[N][V]);        }    }}</code></pre><h1 id="HDU1171"><a href="#HDU1171" class="headerlink" title="HDU1171"></a>HDU1171</h1><p><a href="&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1171&quot;">Big Event in HDU</a></p><p>解题思路：<br>十分巧妙的一题，可以转换成01背包问题。<br>dp数组的意义：<strong>dp[MAX]=不超过MAX而能取得的最大价值</strong><br>那么对全部物品遍历价值val[i]，有<strong>dp[x] = max(dp[x], dp[x-val[i]]+val[i])</strong><br>根据题意B就是dp[sum(总价值)/2]，A就是总价值-dp[sum/2]</p><p>代码如下：</p><pre><code>import java.util.Scanner;import static java.lang.Math.max;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n;        while ((n=sc.nextInt())&gt;0){            int sum = 0;            int index = 0;            int dp[] = new int[200000];            int val[] = new int[5005];            for(int i = 0 ; i &lt; n ; i ++){                int a = sc.nextInt();                int b = sc.nextInt();                while(b--&gt;0) {                    val[index++] = a;                    sum += a;                }            }            for(int i = 0 ; i &lt; index ; i ++){                for(int j = sum/2 ; j &gt;= val[i] ; j-=val[i]){                    dp[j] = max(dp[j], dp[j-val[i]]+val[i]);                }            }            System.out.println((sum-dp[sum/2]+&quot; &quot;+dp[sum/2]));        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高位水仙花数算法优化</title>
      <link href="/2018/11/11/narcissistic/"/>
      <url>/2018/11/11/narcissistic/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>算法思路：<br>以三位的水仙花数为例——</p><ol><li>432各位立方幂和为99，小于100，则不能使用；</li><li>433各位立方幂和为118，但118并不由4 3 3三个数组成，则不是水仙花数；</li><li>531各位立方和为153，且153由5 3 1组成，则是水仙花数；</li><li>777各位立方和为1029，大于999，则不能使用，结束循环。</li></ol><p>再通过预处理（初始化0~9的N次幂）+递归减少运算量。<br>直接看代码吧：</p><pre><code>import java.math.BigInteger;/** * @class: Narcissistic * @author: Chitose * @date: 2018/11/11 * @description: */public class Narcissistic  {    public static int size = 21;    public static BigInteger powArray[] = new BigInteger[10]; // 记录0~9的size次方    public static int usedTimes[] = new int[10];// 记录0~9的使用次数    public static BigInteger powArrayTimes[][]; //记录0到9中任意数字i的N次方乘以其出现的次数j的结果（i^N*j）    public static BigInteger MAX; // size位的数字能表示的最大值    public static BigInteger MIN; // size位的数字能表示的最小值    public static void main(String[] args) {        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10; i++) {// 初始化powArray[]            powArray[i] = (new BigInteger(&quot;&quot; + i)).pow(size);        }        MIN = BigInteger.valueOf(10).pow(size - 1); // 初始化最小值        MAX = BigInteger.valueOf(10).pow(size);     // 初始化最大值（不能等于这个值）        powArrayTimes = new BigInteger[10][size + 1];  //初始化powArrayTimes[][]        for (int i = 0; i &lt; 10; i++) {            powArrayTimes[i][0] = BigInteger.valueOf(0);            for (int j = 1; j &lt; size + 1; j++) {                powArrayTimes[i][j] = powArrayTimes[i][j - 1].add(powArray[i]);            }        }        solve(9, 0, BigInteger.ZERO);        long end = System.currentTimeMillis();        System.out.println(end-start+&quot;毫秒&quot;);    }//index:当前轮到的0~9数字   used:当前已使用的数字总数   now:当前各数字幂和    static void solve(int index, int used, BigInteger now){        if(index == 0){                     //若index到0了则剩下的全部都是0            usedTimes[0] = size - used;            solve(-1, size, now);            usedTimes[0] = 0;            return;        }        if(used == size){            if(now.compareTo(MIN)&lt;0) {      //若现在值还是小于最小值，退出                return;            }            String strNow = now.toString();            int realUsedTimes[] = new int[10];                  // 记录真实的数中0~9的使用次数            for(int i = 0 ; i &lt; strNow.length() ; i++){                realUsedTimes[strNow.charAt(i)-&#39;0&#39;]++;            }            for(int i = 0 ; i &lt; 10 ; i++){                if(realUsedTimes[i] != usedTimes[i]) {          //若比对真实值与使用数不同则退出递归                    return;                }            }            System.out.println(now);                            //如果0~9的使用次数都相同才打印            return;        }        //递归主要部分        for(int i = 0 ; i &lt; size - used ; i++){            if(now.add(powArrayTimes[index][i]).compareTo(MAX)&gt;=0){          //如果已经超过最大值直接退出这一层递归                return;            }            usedTimes[index] = i;       //使用i次index的数            solve(index-1, used+i, now.add(powArrayTimes[index][i]));            usedTimes[index] = 0;       //还原使用次数        }    }}</code></pre><p>以21位的水仙花数做例子，输出如下：</p><blockquote><p>128468643043731391252<br>449177399146038697307<br>4.155秒</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程（二）——JMM与线程安全</title>
      <link href="/2018/11/09/thread2/"/>
      <url>/2018/11/09/thread2/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><em>这一篇将涉及比较多底层知识，代码较少但都是干货。</em></p><hr><h2 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM (Java Memory Model)"></a><strong>JMM</strong> <em>(Java Memory Model)</em></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在讲线程安全之前必须提及Java内存模型，因为线程安全是与它息息相关的。<br>&nbsp;&nbsp;&nbsp;&nbsp;首先，JMM是一个抽象的规范，它本身不存在，通过JMM，JVM虚拟机可以屏蔽掉各种硬件或者操作系统的差异，规范了JVM如何与计算机内存协同工作的、线程之间共享资源的方式（如一个线程如何看到其他线程修改后的变量，同步访问共享变量等）。<br><img src="/2018/11/09/thread2/JMMDetail.png" alt="JMM"><br>&nbsp;&nbsp;&nbsp;&nbsp;如图，Java内存模型规定了所有变量都存储在主内存中<em>（即图中的Heap，主内存有时候也称堆内存）</em>，即主内存是任何线程都能访问到的。</p><ul><li>存放：所有<strong>对象</strong>及他们的成员变量、数组元素、静态域</li><li>优点：他是运行时的数据区，运行时动态分配内存的，生存期不必实现确定，由Java垃圾回收管理</li><li>缺点：存取速度相对较慢</li><li>Tips：只有获得对象的引用的变量才能被获得该引用的线程所访问</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM运行的单位（实体）实际上就是线程，每个线程创建时JVM都会为它分配一个私有的工作内存<em>（即图里的Thread Stack，它有时候也被称为线程栈）</em>，不同线程间无法访问，用于存放该线程拥有的变量。</p><ul><li>存放：基本类型<strong>变量</strong>（包括局部变量与方法变量等）以及对象的引用</li><li>优点：存取速度十分快，仅次于CPU的寄存器</li><li>缺点：生存期与大小必须事先确定</li><li>Tips：当要一个线程要引用一个变量的时候，实际上是该线程从主内存获得一份<strong>私有拷贝</strong>到工作内存中去，在写操作时会再写回。</li></ul><blockquote><p><strong>注意：必须搞清楚一件事是Java的内存划分与Java内存模型是不同层次的概念！</strong><br>关于Java的内存划分我会在本文最后放出相应的图示与解释。<br>此处JMM定义的主内存可以说是Java内存区域划分中的：堆与方法区<br>而工作内存则是：程序计数器、虚拟机栈及本地方法栈</p></blockquote><h3 id="同步八操作"><a href="#同步八操作" class="headerlink" title="同步八操作"></a>同步八操作</h3><p>图示为Java内存模型的操作：<br><img src="/2018/11/09/thread2/JMM.jpg" alt="JMM"><br><em>如果了解计算机的缓存一致性MESI的人应该能看得出来Java内存模型跟多处理机进行缓存一致性操作有异曲同工之妙，至于那是什么可以去搜一下或者看在本文最后的东西。</em></p><p><strong>lock(锁定)</strong>：作用于主内存，让主内存变量标示为某一线程的独占的状态。<br><em>当进行lock时会使工作内存中的该变量清空，在执行前需重新执行load和assign</em></p><p><strong>unlock(解锁)</strong>：作用于主内存，让主内存变量的独占状态解除，可以被其他线程锁定。<br>。<em>进行unlock必须先把该变量从之前锁定的线程的工作内存中同步到主内存</em></p><p><strong>read(读取)</strong>：作用于主内存的变量，把一个变量值从主内存读取到线程的工作内存中，以便于load的操作。<br><em>load与read不能单独出现！</em></p><p><strong>load(载入)</strong>：作用于工作内存的变量，把主内存read到的变量放入工作内存的变量副本中。<br><em>一个新变量是只能在主内存中诞生，不允许工作内存中用一个未被初始化的变量，即use和store之前必须有load和assign</em></p><p><strong>use(使用)</strong>：作用于工作内存的变量，将变量副本取出来到执行引擎中执行。</p><p><strong>assign(赋值)</strong>：作用于工作内存的变量，将执行引擎中收到的值赋予工作内存中的变量。<br><em>一个线程assign过的变量必须从工作内存写回主内存</em></p><p><strong>store(存储)</strong>：作用于工作内存的变量，将工作内存的变量存入主内存中，便于进行write操作。<br><em>store与write不能单独出现！</em></p><p><strong>write(写入)</strong>：作用于主内存的变量，把store的变量传到主内存的变量中。</p><p>当在多线程环境进行这同步八操作的时候，就有可能引致线程安全问题。那什么是线程安全？</p><h2 id="线程安全的概念"><a href="#线程安全的概念" class="headerlink" title="线程安全的概念"></a>线程安全的概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;线程安全是指在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，得到预期想要的效果，不会出现数据污染等意外情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;而线程安全主要从三个方面来考察：原子性、可见性、有序性。</p><ul><li><strong>原子性</strong>：指不可分割性，互斥访问的操作（同一时刻只能有一个线程进行的操作）；</li><li><strong>可见性</strong>：指线程之间，一个线程对主内存修改的结果，另一个线程能马上正确的看到；</li><li><strong>有序性</strong>：一个线程观察其他线程的指令执行顺序，在必要的执行顺序错误则无序（CPU会为提高速度而进行乱序执行优化）。</li></ul><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>因为前面讲了线程池真™好啊，这里就用线程池做例子了。</p><pre><code>public class ConcurrencyExample {    //请求总数    public static int clientTotal = 1000;    //线程池大小    public static int threadTotal = 50;    //计数器    private static int count = 0;    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0 ; i &lt; clientTotal ; i++){            executorService.execute(() -&gt; add());        }        executorService.shutdown();        while(!executorService.isTerminated()) { Thread.sleep(100);}    //由于main可能先比线程池的任务执行的快，所以在这等待，让所有队列中的线程完成后再结束        System.out.println(&quot;count (should be 1000) : &quot; + count);    }    private static void add(){        count++;    }}</code></pre><p> 很明显，这串代码就是为了用一千个任务（任务就是每个任务都给一个共享的count加1）得到一个一千的值，所以如果输出<code>count (should be 1000) : 1000</code>的话就是我们想看到的。那么就执行这代码几次试试：</p><blockquote><p>count (should be 1000) : 979<br> count (should be 1000) : 956<br> count (should be 1000) : 982<br> count (should be 1000) : 965<br> count (should be 1000) : 973</p></blockquote><p>没有一次是达到目的的，每次都比1000少那么点，那问题出在哪里了呢？</p><p>相信是个人都知道x++这种自增符的用处相当于x=x+1，即先取出x的值，计算x+1，并把这个值传入到x里。<br>这里既有读操作也有写操作，写操作依赖于读操作，而这整个x++并非是一个原子性的操作，所以很有可能会产生这样的情况：线程1读完x=1后线程1准备写x=2的时候，线程2还在读之前的x=1，然后线程2写的时候也是写x=2，那么这两个线程本应该加到3也只能加到2。</p><p>那么这样就很清楚了为什么会发生这样的线程不安全问题了。</p><p>关于原子性，有几个常见的解决方法：</p><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><pre><code>public class ConcurrencyExample {    //请求总数    public static int clientTotal = 1000;    //允许同时并发执行数    public static int threadTotal = 50;    //计数器    private static Integer count = 0;    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0 ; i &lt; clientTotal ; i++){            executorService.execute(() -&gt; add());        }        executorService.shutdown();        while(!executorService.isTerminated()) { Thread.sleep(100);}        System.out.println(&quot;count (should be 1000) : &quot; + count);    }    private synchronized static void add(){        count++;    }    //      这个也行：    //      private static void add(){    //      synchronized (ConcurrencyExample.class) {    //        count++;    //      }    //  }    //      但这个不行：    //      private static void add(){    //      synchronized (count) {    //        count++;      //每次执行这个，count都默认指向一个新的变量，那么锁就失效了    //      }    //  }}</code></pre><blockquote><p>count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000</p></blockquote><p>通过synchronized关键字，使任何线程进入代码块之前获得同步监视器锁，其他线程将不能获得同步锁而只能等待直到锁的释放。这里方法同步，对调用该方法的实例上锁，每次只能由一个线程获得锁来访问add()方法，那么效果便就如我们所愿了。<br>但是synchronized有时并不能满足我们的需求，首先sync只有完成了锁定的代码段才会解锁（或者其他如异常抛出或者wait()），不可中，，而且他是一种基于JVM的隐式锁，若里面代码片段过于复杂的时候就会资源占用，在竞争激烈的时候会导致性能下降，那么反而失去了多线程的必要性。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Java SE5提供了一种显锁式锁：ReentrantLock，通过显示的调用lock与unlock的方式进行锁定</p><pre><code>public class ConcurrencyExample {    //请求总数    public static int clientTotal = 1000;    //允许同时并发执行数    public static int threadTotal = 50;    //计数器    private static int count = 0;    private static final ReentrantLock lock  = new ReentrantLock();    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0 ; i &lt; clientTotal ; i++){            executorService.execute(() -&gt; add());        }        executorService.shutdown();        while(!executorService.isTerminated()) { Thread.sleep(100);}        System.out.println(&quot;count (should be 1000) : &quot; + count);    }    private static void add(){        lock.lock();        count++;        lock.unlock();    }}</code></pre><p>实际上与synchronized没太多区别，主要是Lock有一个比较特别的多一个tryLock()，能让其他线程如果获得不到锁去做别的事，而能更灵活的使用锁。</p><h3 id="Atomic类"><a href="#Atomic类" class="headerlink" title="Atomic类"></a>Atomic类</h3><p>J.U.C(Java.util.concurrency)包内提供了一些十分有用的原子类如：AtomicInteger、AtomicBoolean、AtomicLong、AtomicReference、LongAdder等<br>这里简单演示其中一个：</p><pre><code>public class ConcurrencyExample {    //请求总数    public static int clientTotal = 1000;    //允许同时并发执行数    public static int threadTotal = 50;    //计数器    private static AtomicInteger count = new AtomicInteger(0);    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0 ; i &lt; clientTotal ; i++){            executorService.execute(() -&gt; add());        }        executorService.shutdown();        while(!executorService.isTerminated()) { Thread.sleep(100);}        System.out.println(&quot;count (should be 1000) : &quot; + count.get());    }    private static void add(){        count.incrementAndGet();        //相当于自增    }}</code></pre><blockquote><p>count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000<br> count (should be 1000) : 1000</p></blockquote><p> 在此AtomicInteger的原子类是线程安全的，这些原子类的实现都是基于一个CAS算法，我们可以看看那个AtomicInteger的内部：<br> <img src="/2018/11/09/thread2/CAS.png" alt="CAS?"><br> 然后再进去看看：<br> ，var1是传入的对象，var2是对象当前的值，var4为加数，var5是通过getIntVolatile()方法获得对象的底层值，通过在死循环里不停使用compareAndSwapInt（就是CAS）比较对象的当前值与其底层值，这里的compareAndSwapInt是Unsafe类中的一个native本地内部方法，若不相同则返回false，若相同则将其值更新为var5+var4。<br> <img src="/2018/11/09/thread2/CAS2.jpg" alt="CAS"><br> 原子类都是通过这种CAS算法来进行安全的修改。</p><p> 顺带讲一种用法，<br> <strong>懒汉单例模式</strong>：</p><pre><code> public class LazySingletonExample {    private LazySingletonExample(){}    private static LazySingletonExample instance = null;    public static synchronized LazySingletonExample getInstance(){        if(instance == null){            instance = new LazySingletonExample();        }        return instance;    }}</code></pre><p>这是懒汉单例模式的一种写法，而在这里通过给getInstance()工厂方法加上synchronized关键字才保证了线程安全，否则会可能导致返回错误值。<br>但是前面也提到了使用方法同步的方式实际上大大降低性能，因为同一时间只能有一个线程能访问对象，所以这种单例模式虽然是线程安全，但是并不推荐，那么我们可以在其之上进行改进，<br>双重同步锁单例模式：</p><pre><code>public class DoubleLazySingletonExample {    private DoubleLazySingletonExample(){}    private static DoubleLazySingletonExample instance = null;    public static synchronized DoubleLazySingletonExample getInstance(){        if(instance == null){                                           //**Mark1**            synchronized (DoubleLazySingletonExample.class) {                if(instance == null) {                    instance = new DoubleLazySingletonExample();        //**Mark2**                }            }        }        return instance;    }}</code></pre><p>通过在里面使用双重锁定来保证了性能的提高，在已经有对象的时候直接不进入sync代码块，不至于让线程一直等待而无法同时使用对象。但是这里仍然有缺陷，假设有这样的情况：<br>首先对象初始化的过程是这样的：</p><ol><li>分配对象内存空间</li><li>初始化对象</li><li><p>使对象指向内存<br>1和（2,3）是不会发生指令重排的，但若2.3.发生指令重排，Thread1完成了3，Thread在Mark1位置判断instance时，因为不为空返回了值，但实际上还是没有初始化，所以非线程安全。所以这时需要给instance加上volatile关键字就解决重排序的问题了，这时这个单例模式便是线程安全的且性能较高：</p><pre><code>public class DoubleLazySingletonExample {private DoubleLazySingletonExample(){}//volatile+双重同步锁private volatile static DoubleLazySingletonExample instance = null;public static synchronized DoubleLazySingletonExample getInstance(){    if(instance == null){                                           //Mark1-Thread2        synchronized (DoubleLazySingletonExample.class) {            if(instance == null) {                instance = new DoubleLazySingletonExample();        //Mark2-Thread1            }        }    }    return instance;}}</code></pre></li></ol><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>对可见性可以举一个例子：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当线程1修改工作内存中的值的时候，必须要写回主内存才能被其他线程看到，但若没有写回就被线程2读的话，就会导致不可见。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;由此易知，导致不可见的原因：</p><ul><li>线程的交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主内存间及时更新</li></ul><h3 id="synchronized-Lock"><a href="#synchronized-Lock" class="headerlink" title="synchronized/Lock"></a>synchronized/Lock</h3><p>如何用锁保证可见性应该是显而易见的了，但还是在这里顺便说一下锁的原理：</p><ul><li>每次获得锁之前，会将所有工作内存中该变量的值清空</li><li>每次释放锁之前，必须把工作内存中变量最新值写回主内存<br>通过这种方式便能保证其他线程读到的是线程改动后的最新值。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile实际上是通过内存屏障禁止重排序来实现可见性的：</p><ul><li>对volatile变量进行write操作的时候，写后加入一条store屏障，将本地内存中共享变量刷到主内存去，那么store指令会在写操作后把最新的值强制刷新到主内存中。同时还会禁止cpu对代码进行重排序优化。这样就保证了值在主内存中是最新的。</li><li>对volatile变量进行read操作的时候，加入一条load屏障，load指令会在读操作前把内存缓存中的值清空后，再从主内存中读取最新的值。<br>实际上可以说是相当于volatile变量的操作是在主内存上进行操作的，因而时刻保证其最新值。<br><img src="/2018/11/09/thread2/vwrite.png" alt="volatile write"><br><img src="/2018/11/09/thread2/vread.png" alt="volatile read"><br>适合用到volatile的场景：</li></ul><ol><li>对volatile写不依赖于当前的值（如自增自减）</li><li>该变量不被包含在具有其他变量的式子中<br>所以可见他比较适合做标记量（如IO操作的完成标记，如下图：）<br><img src="/2018/11/09/thread2/vuse.png" alt="volatile use"></li></ol><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。从Java源代码到最终实际执行的指令序列，会依次经过这三种重排序：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>对于某些Happen-before原则的操作，是无须额外操作便能达到有序性的：</p><ol><li>程序次序规则：<strong>一个线程</strong>内，按照代码执行，书写在前面的操作必定先行发生于书写在后面的操作。</li><li>锁定规则：一个unlock操作必定先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行必定发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A必定先行发生于操作C</li><li>线程启动原则：Thread对象的start()方法必定先行发生于此线程的每一个动作</li><li>线程中断规则:对线程interrupt()方法的调用必定先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()方法返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成必定先行发生于他的finalize()方法的开始</li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Java的内存划分"><a href="#Java的内存划分" class="headerlink" title="Java的内存划分"></a>Java的内存划分</h3><p><img src="/2018/11/09/thread2/JVMM.jpg" alt="JVM Memory"><br>&nbsp;&nbsp;&nbsp;&nbsp;左边和右边有时也被称为堆区和栈区，相对Java内存模型来看其实差不多，跟我们平时所说的堆和栈，都可以运用。虽然这个清不清楚不会太影响这里解释Java内存模型，对于JVM内存划分想要详情了解的可以参考别的大佬的博客：<a href="https://www.cnblogs.com/zhguang/p/3257367.html" target="_blank" rel="noopener">Java内存区域划分</a></p><h3 id="计算机硬件架构的图示"><a href="#计算机硬件架构的图示" class="headerlink" title="计算机硬件架构的图示"></a>计算机硬件架构的图示</h3><p><img src="/2018/11/09/thread2/cpu.jpg" alt="CPU"><br>&nbsp;&nbsp;&nbsp;&nbsp;由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。但这里就会有一个问题，多个处理器进行处理如果发生同步的操作的时候就可能会出现数据错误，这时就需要有MESI这类缓存一致性协议了。具体可参考：<a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener">维基百科对缓存一致性的介绍</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程（一）——线程的介绍与创建</title>
      <link href="/2018/10/21/thread/"/>
      <url>/2018/10/21/thread/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><em>11.9已更新：ThreadPoolExecutor，下一次会更新更多线程池</em><br><em>这一篇作为Java线程系列的开篇吧，简单的介绍一下一些普遍的线程和线程的创建方式。</em></p><hr><h1 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h1><p>先放一张随处可见的线程状态转换图：<br><img src="/2018/10/21/thread/images/status.jpg" alt="Thread status"><br>所以啥是线程？<br>平时我们用的程序他运行起来了，他就叫进程（运行中的程序），是一个动态的概念，<br>而进程内部可能包含很多顺序执行任务，那这每一个任务就是一个线程。<br>进程和线程很类似，但又区别很大：</p><p>相同点：</p><ul><li><strong>进程的存在是为了让操作系统同时运行多个程序；线程的存在是为了让进程同时执行多个任务。</strong></li><li><strong>他们都可以并发执行</strong></li></ul><p>区别：</p><ul><li><strong>对于每一个进程系统都会分配一定内存空间与资源，而这些分配的内存空与资源在不同进程之间是很难共享的，所以说进程是地址独立、资源独立的；而对于每一个线程，他们只能共享进程中的资源，尤其是CPU（线程只有获得CPU才能够执行，说到底CPU也是系统分配给进程的）</strong></li><li><strong>一个程序至少要有一个进程，一个进程至少要有一个线程</strong></li></ul><p>为什么使用线程？</p><ul><li><strong>线程之间能共享资源，共享内存十分容易，而进程不行！</strong></li><li><strong>创建线程代价比创建进程要小得多，所以用多线程来实现多任务并发比多进程效率要高。</strong></li></ul><hr><h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><p>除了众所周知的直接继承于Thread和实现Runnable的方法以外，还有Java 5后提供的Future+Callable和线程池，在这里写一下他们的方式与区别。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>直接通过继承于Thread的方式来创建：</p><ol><li>需要一个继承于Thread的类，并重写其中的run()方法</li><li>新建该类的对象</li><li>通过该对象的start()启动线程<pre><code>public class TestThread extends Thread{private int i ;//线程体@Overridepublic void run() {    for( ; i &lt;100 ; i++){       System.out.println(getName()+&quot; &quot;+i);    }}public static void main(String[] args) {    new TestThread().start();    new TestThread().start();}}</code></pre>此时输出的效果部分如下：<blockquote><p>Thread-1 42<br>Thread-0 66<br>Thread-0 67<br>Thread-1 43<br>Thread-1 44<br>Thread-0 68<br>Thread-1 45<br>Thread-0 69</p></blockquote></li></ol><p>可以看见，两个线程都混杂在一起，谁也不能影响到谁的变量i，这是以继承的方式。</p><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>Runnable的定义可以理解为该方法的反型封装，即它执行能做的事情。Runnable的创建线程的方式：</p><ol><li>需要一个实现Runnable的类，并实现其中的run()方法</li><li>创建这个类的实例，作为参数创建一个新的Thread对象</li><li>通过该对象的start()启动线程<pre><code>public class TestRunnable implements Runnable{//共用的成语属性private int i;//实现Runnable的run方法，线程体public void run() {    for (; i &lt; 100; i++) {        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);    }}public static void main(String[] args) {    TestRunnable tr = new TestRunnable();       //创建Runnable实例    new Thread(tr,&quot;Runnable-Thread1&quot;).start();  //传参构建Thread    new Thread(tr,&quot;Runnable-Thread2&quot;).start();}}</code></pre>部分输出效果：<blockquote><p>Runnable-Thread1 33<br>Runnable-Thread2 34<br>Runnable-Thread1 35<br>Runnable-Thread2 36<br>Runnable-Thread2 38<br>Runnable-Thread2 39<br>Runnable-Thread2 40<br>Runnable-Thread2 41<br>Runnable-Thread1 37</p></blockquote></li></ol><p>显然Thread1和Thread2明显共用了属性i，可见，当两个两个线程同时以同一个Runnable的实现类作为参数的时候，他们能共用那个Runnable的属性。（当然要是你创建两个Runnable实例效果会跟Thread一样，但是那样就没用Runnable的意义了）<br>但因为getName()是Thread类里的方法，所以必须用Thread的静态方法Thread.currentThread()先获得当前线程对象才能调用getName()。</p><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>Callable创建线程的方式跟Runnable很类似，虽然Thread的构造方法参数没有Callable类参数，但FutureTask实现了Runnable接口：</p><ol><li>需要一个实现Callable的类（Callable的泛型就是返回值的类型），并实现其中的call()方法</li><li>创建这个类的实例，作为参数包装成一个新的FutureTask对象</li><li>FutureTask作为参数创建一个新的Thread对象</li><li>通过该对象的start()启动线程</li><li><p>通过get()可以获得返回值（记得捕获异常）</p><pre><code>public class TestCallable implements Callable&lt;Integer&gt; {private int i;//线程体@Overridepublic Integer call(){    for(; i &lt; 100 ; i++){        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);    }    return i;}public static void main(String[] args) {    TestCallable tc = new TestCallable();       //创建Callable实例    FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(tc);        //包装成FutureTask    new Thread(task,&quot;Callable-Thread&quot;).start();             //当target传参进去    try {        System.out.println(&quot;返回值：&quot;+task.get());    } catch (Exception e) {        e.printStackTrace();    }}}</code></pre><p>部分输出效果：</p><blockquote><p>Callable-Thread 96<br>Callable-Thread 97<br>Callable-Thread 98<br>Callable-Thread 99<br>返回值：100</p></blockquote></li></ol><p>虽然用Callable创建起来比Runnable要复杂，但从这里可以看出来了：利用Callable不仅可以抛出异常，而且可以通过get()方法获得线程执行返回的信息。<br>其次要注意的是，这里我没有创建两个线程，只有一个主线程和一个Callable的线程，是因为使用同一个FutureTask来创建线程会被认为是“不安全的”，在Callable的线程体call()执行一次之后会将status改成不再是NEW，而不是NEW的callable将直接退出，无法执行线程体：</p><pre><code>public void run() {    if (state != NEW ||        !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread()))    return;</code></pre><p>所以如果用像前面Runnable那样用一个target创建两个线程的话，第二个线程将会在执行线程体之前就挂掉。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池Java5在之前只能自己手动去创建，现在已经有了多种方法如Executors工厂，ForkJoinPool，在这里先写Executors工厂类吧，利用线程池的方式：</p><ol><li>先调用Executors静态工厂方法创建一个ExecutorService或ScheduledExecutorService线程池对象（创建时可传入ThreadFactory来进行规定创建线程，下面CacheThreadPool会有例子）</li><li>创建Runnable/Callable实例，利用线程池对象的execute()和submit()或者schedule()来传入线程池并执行（callable必须用submit())</li><li>当任务完成后，执行shutdown()来关闭线程池</li></ol><p>附上一张线程池状态图：<br><img src="/2018/10/21/thread/images/poolstatus.jpg" alt="Thread Pool Status"></p><blockquote><p>其中newCacheThreadPool(), newFixedThreadPool(int nThreads), newSingleThreadExecutor()是ExecutorService对象，而newScheduledThreadPool(int corePoolSize), newSingleScheduledThreadPool()为ScheduledExecutorService对象，下面我会为前三个常用的做简单的例子。</p></blockquote><p>###<strong>FixedThreadPool</strong>：</p><pre><code>    public class PoolTest {        static class PoolRunnable implements Runnable{            private int i;            public void run() {                for (; i &lt; 100; i++) {                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);                }            }        }        public static void main(String[] args) {            ExecutorService executorService = Executors.newFixedThreadPool(3);            PoolRunnable p = new PoolRunnable();            executorService.execute(p);            executorService.submit(p);            executorService.shutdown();        }    }</code></pre><p>部分输出效果：</p><blockquote><p>pool-1-thread-1 41<br>pool-1-thread-2 45<br>pool-1-thread-1 46<br>pool-1-thread-2 47<br>pool-1-thread-2 49<br>pool-1-thread-2 50<br>pool-1-thread-2 51<br>pool-1-thread-2 52<br>pool-1-thread-1 48<br>pool-1-thread-2 53<br>pool-1-thread-1 54</p></blockquote><p>可见与用Runnable的方式效果相差无几，只是方式不一样了而已。<br>而三种Executor都有他们特别的地方，用<em>Thinking in Java</em>的原话来说的话就是这样：</p><blockquote><p>CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程的时候停止创建新线程，因此它是合理的Executor首选。只有在这种方式会引发问题的时候，才需要用到FixedThreadPool。<br>FixedThreadPool可以一次性预先执行代价高昂的线程分配，然后限制现成的数量不用每个任务都要付出创建线程的开销，直接从池中获取线程，且不会滥用可获得的资源。<br>SingleThreadExecutor就像是数量为1的FixedThreadPool，如果向它提交了多个任务，这些任务都将排队，所有任务将使用同一个进程。（但还是有区别，他提供了一种重要的并发保证，保证不会有两个线程被并发调用）</p></blockquote><p>###<strong>SingleThreadExecutord</strong>：</p><pre><code>public class PoolTest2 {    static class PoolRunnable2 implements Runnable{        public void run() {            int random = (int) Math.round(Math.random()*9+1);            System.out.println(&quot;我是&quot;+Thread.currentThread().getName()+&quot;, 我先睡&quot;+random+&quot;秒&quot;);            try {                Thread.sleep(random*1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName()+&quot;已经溜了&quot;);        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newSingleThreadExecutor();//换成newCachedThreadPool试试        for(int i = 0 ; i &lt; 5 ; i++) {            PoolRunnable2 p = new PoolRunnable2();            executorService.execute(p);        }        executorService.shutdown();    }}</code></pre><p>效果如图：</p><blockquote><p>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡7秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡5秒<br>pool-1-thread-1已经溜了</p></blockquote><p>可见该线程池中始终只有一个线程，一直使用的也是那一个线程。</p><p>###<strong>CacheThreadPool</strong><br>在利用线程池创建线程的时候我们很容易发现，几种创建线程池的方式都可以传入类型为ThreadFactory的参数，实际上线程池默认会有一个ThreadFactory的成员属性，当我们不传这个参数时默认为Executors.defaultThreadFactory()，里面包含了他所规定的创建线程时的操作：</p><pre><code>    static class DefaultThreadFactory implements ThreadFactory {        private static final AtomicInteger poolNumber = new AtomicInteger(1);        private final ThreadGroup group;        private final AtomicInteger threadNumber = new AtomicInteger(1);        private final String namePrefix;        DefaultThreadFactory() {            SecurityManager s = System.getSecurityManager();            group = (s != null) ? s.getThreadGroup() :                                  Thread.currentThread().getThreadGroup();            namePrefix = &quot;pool-&quot; +                          poolNumber.getAndIncrement() +                         &quot;-thread-&quot;;        }        public Thread newThread(Runnable r) {            Thread t = new Thread(group, r,                                  namePrefix + threadNumber.getAndIncrement(),                                  0);            if (t.isDaemon())                t.setDaemon(false);            if (t.getPriority() != Thread.NORM_PRIORITY)                t.setPriority(Thread.NORM_PRIORITY);            return t;        }    }</code></pre><p>那么我们实际上也可以定义一个自己的ThreadFactory来<strong>定义线程池在创建线程时候的操作（这就是ThreadFactory的作用）</strong>。<br>在这里既然讲到了ThreadFactory，那么也顺带讲一讲线程的异常捕获吧。线程的异常由于线程的本质特性，使得不能捕获到线程中逃逸的异常（你大可以尝试在run中抛出一个异常，然后在main中尝试去捕获它），在Java SE5以前只能使用线程组进行捕获<del>（而线程组已被Sun公司的架构师表示——“最好把线程组看成是一次不成功的尝试，你只要忽略它就行了”）</del>，而Java SE5线程池的出现已经能完美的解决这一问题。<br>我们通过前面所提到的ThreadFactory能修改线程池生产线程的方式——在生产时候为每个Thread对象附上一个异常处理器UncaughtExceptionHandler，那么在抛出异常的时候便会通过处理器进行捕获处理：</p><pre><code>public class PoolTest3 {    static class ExecptionThread implements Runnable{        @Override        public void run() {            throw new RuntimeException();        }    }    static class EHThreadFactory implements ThreadFactory{        @Override        public Thread newThread(Runnable r) {            Thread t = new Thread(r);            t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {                @Override                public void uncaughtException(Thread t, Throwable e) {                    System.out.println(&quot;catch &quot; + e);                }            });//你也可以创建一个类继承于Thread.UncaughtExceptionHandler来进行使用而不使用匿名类            return t;        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newCachedThreadPool(new EHThreadFactory());        executorService.execute(new ExecptionThread());        executorService.shutdown();    }}</code></pre><p>效果如下</p><blockquote><p>catch java.lang.RuntimeException</p></blockquote><p>你甚至可以调用静态设置Thread.setDefaultUncaughtExceptionHandler()来让所有没有设置未捕获异常处理器的线程调用默认的未捕获异常处理器。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><strong>ThreadPoolExecutor</strong></h3><p>我们已经知道是通过工厂方法来创建的线程池，那那些线程池实际上都是什么？<br>只要你看了看源代码就知道，无论是创建Fixed的还是Cached的线程池，其实都是new 一个 ThreadPoolExecutor(但是是ExecutorService的实现，具体可看下图），只是他们new出的ThreadPoolExecutor参数不同。</p><p>如图可见他们的关系：<br><img src="/2018/10/21/thread/images/relation.jpg" alt="relation"></p><p>而他有以下几个核心参数用于初始化：</p><p>corePoolSize：核心线程数<br>maximumPoolSize：最大线程数<br>workQueue：阻塞队列，存储等待执行的任务，有三种<br>keepAlive：线程没有任务时最多保持多久才终止（单位为unit）<br>threadFactory：线程工厂，用来设置线程池生产线程的方式<br>rejectHandler：拒绝任务的时候的策略</p><p>他有几个可用于监控的重要方法：</p><p>getTaskCount()：获得线程池已执行和未执行的任务总数<br>getCompletedTaskCount()：获得以完成的任务数量<br>getPoolSize()：线程池中当前线程的数量<br>getActiveCount()：当前线程池中正在执行任务的线程数量</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>直接用Thread的方式创建多线程的优势：</p><p><strong>编程简单，像获得当前线程直接通过实例的方法即可，十分适合那些短小精悍的线程。</strong></p><p>用实现Runnable的方式创建多线程的优势：</p><p> <strong>1.能继承与实现更多的类</strong><br> <strong>2.能通过共用target来进行共享资源</strong></p><p>用实现Callable的方式创建多线程的优势：</p><p> <strong>1.能继承与实现更多的类</strong><br> <strong>2.能捕获异常进行处理</strong><br> <strong>3.能获得线程执行的返回值，在编程上能有更多空间</strong></p><p>用线程池的方式的优势：</p><p><strong>1.target通过submit()或schedule()传入线程池后，线程池会启用一个线程来执行target里的run()或call(),但执行结束后不会死亡，将进入空闲状态保留在线程池中，等待下一个target时使用。这样在创建大量的短暂线程的时候可以不用像Thraed那样用一个创建一个，性能差又浪费资源，直接从线程池中使用。</strong><br><strong>2.可以通过控制线程池的最大线程数来控制系统并发线程数，统一管理线程，防止线程创建过多占用过多系统资源而导致的JVM崩溃，也避免的资源竞争</strong><br><strong>3.利用ScheduledExecutorService能指定延迟或周期性的执行线程任务</strong><br><strong>4.集合Runnable和Callable的优点——能共享资源，能处理返回值等</strong><br><strong>5.使用Executor能明显感到线程与任务是不同的概念，因为它甚至替你创建与管理线程，他将用户提交与运行分离开来，当然你也可以通过ThreadFactory来自定义线程池中线程的创建方式</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HttpURLConnection和HttpClient简单上手</title>
      <link href="/2018/10/13/http-easy/"/>
      <url>/2018/10/13/http-easy/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;最近做项目过程中要搞HTTP请求的时候总是只能用以前写好的URLUtil，略是僵硬，想起之前做安卓有用过okhttp和httpclient，试着在Java里用一用并对比一下他们的效果吧。本章代码已上传<a href="https://github.com/ChitoseYono/HttpUtil" target="_blank" rel="noopener">github</a>。</p><hr><h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;原生Java自带的http请求方式，抽象类URLConnection是表示应用程序和URL之间的通信链接的所有类的超类。 该类的实例可以用于从URL引用的资源中读取和写入。而HttpURLConnection是最常用于进行Http链接的他的子类。<br>请求方式一般步骤（参考JDK文档）：</p><ol><li>通过在URL上调用openConnection方法创建连接对象。</li><li>设置参数和一般请求属性。 </li><li>使用connect方法实现与远程对象的实际连接。</li><li>远程对象变得可用。 可以访问头字段和远程对象的内容。</li></ol><h3 id="简单GET请求"><a href="#简单GET请求" class="headerlink" title="简单GET请求"></a>简单GET请求</h3><pre><code>public String getByConnection(String str) throws IOException {    //1.创建连接    URL url = new URL(str);    HttpURLConnection httpConn = (HttpURLConnection)url.openConnection();    //2.设置参数    httpConn.setRequestMethod(&quot;GET&quot;);       //请求类型    httpConn.setRequestProperty( &quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot; );  //请求属性    httpConn.setConnectTimeout(100000);     //连接超时时间    httpConn.setReadTimeout(100000);        //读取超时时间    httpConn.setDoInput(true);              //是否读入    httpConn.setDoOutput(true);             //是否输出    httpConn.setUseCaches(true);            //是否使用缓存    //3.连接    httpConn.connect();                     //其实会调用所以不必要用connect()    //4.访问连接内容    BufferedReader reader = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));    String line;    StringBuffer buffer = new StringBuffer();    while ((line = reader.readLine()) != null) {        buffer.append(line);    }    reader.close();    httpConn.disconnect();    return buffer.toString();}</code></pre><h3 id="进行上传文件"><a href="#进行上传文件" class="headerlink" title="进行上传文件"></a>进行上传文件</h3><p>之所以不写Post原因是上传文件实际上就是一种特殊的POST，只是比简单的POST要多上不少东西，对于简单的POST可以只是向连接的OutputStream中写入键值对便可以了（跟get没什么区别的话也没太多必要用POST)。</p><p>首先由于HttpURLConnection的局限性（他只是一个抽象类，没有什么特别的集成），对于上传文件这类”multipart/form-data”类型的请求类型只能由我们手动拼接Header <del>（我来组成头部！）</del>，所以在说如何用HttpURLConnection进行上传文件前先说说上传时的Header：</p><p>可见在这用POST上传图片实际上就是模拟表单上传，而这时需要有拼接请求体：<br><img src="/2018/10/13/http-easy/images/header.png" alt="Http Header"></p><ol><li>请求体中需要先以”—–一串随机数字(代码中用的是UUID的随机序列)\r\n(\r\n的作用是换行)”来上下分隔。所以在前后都要加上boundary</li><li>然后写入Content-Disposition:form-data;name=”<strong>(此处需要与服务器约定)</strong>“;filename=”<strong>文件名</strong>“;</li><li>通过InputStream写入HttpURLConnection的OutputStream中。</li><li>最后以”—–那一串数字–\r\n”结尾。</li></ol><pre><code>public String uploadByConnection(String str) throws IOException{    //1.创建连接    URL url = new URL(str);    HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();    //2.设置参数    String Boundary = UUID.randomUUID().toString();     //请求边界    httpConn.setRequestMethod(&quot;POST&quot;);                  //请求类型    httpConn.setRequestProperty(&quot;Charset&quot;, &quot;utf-8&quot;);    //请求属性    httpConn.setRequestProperty( &quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot;+Boundary ); //请求属性    httpConn.setConnectTimeout(100000);     //连接超时时间    httpConn.setReadTimeout(100000);        //读取超时时间    httpConn.setDoInput(true);              //是否读入    httpConn.setDoOutput(true);             //是否输出    httpConn.setUseCaches(true);            //是否使用缓存    //3.HTTP请求体    DataOutputStream out = new DataOutputStream(httpConn.getOutputStream());    out.writeUTF(&quot;Content-Disposition: form-data; name=\&quot;user_upload_icon\&quot;;filename=\&quot;foo.jpg\&quot;\r\n\r\n&quot;);    InputStream in = new FileInputStream(&quot;src/foo.jpg&quot;);    byte[] b = new byte[1024];    int l = 0;    while((l = in.read(b)) != -1) out.write(b,0,l); // 写入文件    out.writeUTF(&quot;\r\n--&quot;+Boundary+&quot;--\r\n&quot;);    out.flush();    out.close();    in.close();    //4.获取响应信息    BufferedReader reader = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));    String line;    StringBuffer buffer = new StringBuffer();    while ((line = reader.readLine()) != null) {        buffer.append(line);    }    reader.close();    httpConn.disconnect();    return buffer.toString();}</code></pre><hr><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;作为Apache下手开发的工具包，使用起来比JDK自带的更为轻松和简单，实现的功能也更多。<br>HttpCLient最关键的方法是执行HTTP请求的方法execute。只要把HTTP请求传入，就可以得到HTTP响应。<br>使用HttpClient请求一个Http请求的步骤为：</p><ol><li>创建一个HttpClient对象</li><li>创建一个Request对象</li><li>使用HttpClient来执行Request请求，得到对方的response</li><li>处理response</li><li>关闭HttpClient</li></ol><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;  &lt;artifactId&gt;httpclient&lt;/artifactId&gt;  &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpmime&lt;/artifactId&gt;    &lt;version&gt;4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><pre><code>compile &#39;org.apache.httpcomponents:httpclient:4.5.6&#39;</code></pre><h3 id="简单的GET请求"><a href="#简单的GET请求" class="headerlink" title="简单的GET请求"></a>简单的GET请求</h3><pre><code>public String getByClient(String str) throws IOException {    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(1000).build();   //可以对请求进行各种配置    HttpGet httpGet = new HttpGet(str);                             //创建Get请求    httpGet.setConfig(requestConfig);                               //设置配置    CloseableHttpResponse response = client.execute(httpGet);       //通过Client执行请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;这绝对是肉眼可见的代码量减少，而且步骤十分清晰。值得一提的是，HttpClient以前的构建方式已经废弃，不能使用了：<br><del>HttpClinet client = new HttpClient();</del></p><h3 id="简单的POST请求"><a href="#简单的POST请求" class="headerlink" title="简单的POST请求"></a>简单的POST请求</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Post请求HttpClient巧妙的设计了HttpEntity类，以它来实现Http请求时的请求体，而且可以以多种方式创建，以便实现各种Post请求如表格，文件等，简单Post请求则可以用简单键值对来创建。</p><pre><code>public static String postByClient(String str, String phone, String password) throws IOException{    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().           //对请求进行各种配置            setConnectTimeout(1000).setConnectionRequestTimeout(1000)            .setSocketTimeout(1000).setRedirectsEnabled(true).build();    List&lt;BasicNameValuePair&gt; list = new ArrayList&lt;BasicNameValuePair&gt;();    //以列表形式创建Post的键值对信息    list.add(new BasicNameValuePair(&quot;phone&quot;,phone));    list.add(new BasicNameValuePair(&quot;password&quot;, password));    UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list,&quot;utf-8&quot;);   //用列表创建表格编码实体    HttpPost httpPost = new HttpPost(str);                          //创建Post请求    httpPost.setConfig(requestConfig);                              //设置配置    httpPost.setEntity(entity);                                     //设置实体信息    CloseableHttpResponse response = client.execute(httpPost);      //执行post请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Post请求上传文件可以利用MultipartEntityBuilder来进行Http请求体的创建，利用addPart(key,body)的形式可以对多形式的value进行记入。</p><pre><code>public static String uploadByClient(String str) throws IOException{    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().           //对请求进行各种配置            setConnectTimeout(1000).setConnectionRequestTimeout(1000)            .setSocketTimeout(1000).setRedirectsEnabled(true).build();    FileBody body = new FileBody(new File(&quot;src/foo.jpg&quot;), ContentType.MULTIPART_FORM_DATA);    HttpEntity entity = MultipartEntityBuilder.create().addPart(&quot;user_upload_icon&quot;,body).build();   //直接用MultipartEntityBuilder创建HTTP实体    HttpPost httpPost = new HttpPost(str);                          //创建Post请求    httpPost.setConfig(requestConfig);                              //设置配置    httpPost.setEntity(entity);                                     //设置实体信息    CloseableHttpResponse response = client.execute(httpPost);      //执行post请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这次简单的说了一下HttpURLConnection和HttpClinet的get/post请求方式，而且也很明显比较可见HttpClient集成的东西，帮我们做到的东西。当然HttpClient可以做的事远远不止get/post请求，他还有各种强大的功能在背后，他的设计与效果是十分精湛的。可以参考下面的链接来看关于HttpClient的更多用法与解析。<br>&nbsp;&nbsp;&nbsp;&nbsp;除了HttpURLConnection和HttpClinet以外，还有许多的优秀网络框架，如okhttp，Volley等，在安卓端开发时备受好评。<del>(而且HttpClient在API 23后都不支持使用了）</del>当然像这样轻量级的框架在做简单请求操作的时候是完全足够的，对于其他的框架以后再看吧。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://kb.cnblogs.com/page/92320/" target="_blank" rel="noopener">ABOUT HEADER</a></li><li><a href="http://hc.apache.org/" target="_blank" rel="noopener">HTTPCLIENT</a></li><li><a href="https://blog.csdn.net/u011179993/article/details/47147909" target="_blank" rel="noopener">HTTPCLIENT TUTORIALS</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Json和Gson的介绍与简单使用</title>
      <link href="/2018/10/05/gson/"/>
      <url>/2018/10/05/gson/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。<br>&nbsp;&nbsp;&nbsp;&nbsp;Gson（又称Google Json）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Json的使用大部分人都会知道的一个轻量级库：<a href="https://github.com/stleary/JSON-java" target="_blank" rel="noopener">org.json</a>，现在仍旧有不少人用，不过他对于json格式到bean格式的转换设计的有缺陷而且麻烦（例如复杂类型转换），对于简单的Json序列化操作时如此<strong>轻量级</strong>的类库是个不错的选择。（毕竟轻量级且五脏俱全）<br>&nbsp;&nbsp;&nbsp;&nbsp;如今对于Json的类库比较广为人知的有<a href="http://json-lib.sourceforge.net/index.html" target="_blank" rel="noopener">json-lib</a>、Jackson、阿里巴巴的 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">FastJson</a>、谷歌的 <a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>，json-lib依赖的包太多速度也慢就不提了，虽然FastJson在parseJson有算法上的先进性以至能大大提高其速度运作，而Jackson在速度上也相差不多，但Gson在对于复杂的类型转换上有更强的性能，对于标准化的类库来说，Gson更能被称为Json的神器，那么在本篇我会写关于org.json的简单使用与Gson的常见使用来比较两者的用途与用法。<br>&nbsp;&nbsp;&nbsp;&nbsp;本章代码已上传到<a href="https://github.com/ChitoseYono/JsonTest" target="_blank" rel="noopener">github</a>，可以查看代码自己研究。</p><hr><h2 id="添加类库依赖"><a href="#添加类库依赖" class="headerlink" title="添加类库依赖"></a><strong>添加类库依赖</strong></h2><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><p><strong>org.json</strong>:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.json&lt;/groupId&gt;    &lt;artifactId&gt;json&lt;/artifactId&gt;    &lt;version&gt;20180813&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>Gson</strong>:</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;  &lt;artifactId&gt;gson&lt;/artifactId&gt;  &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a><strong>Gradle</strong></h3><p><strong>org.json</strong>:</p><pre><code>compile group: &#39;org.json&#39;, name: &#39;json&#39;, version: &#39;20180813&#39;</code></pre><p><strong>Gson</strong>:</p><pre><code>dependencies {  implementation &#39;com.google.code.gson:gson:2.8.5&#39;}</code></pre><hr><h2 id="Json数据与Bean"><a href="#Json数据与Bean" class="headerlink" title="Json数据与Bean"></a><strong>Json数据与Bean</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在正式介绍前简单看看本章会用到的Json数据与相应的JavaBean：</p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a><strong>Json</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Json数据例子中简单地囊括Json中所有的类型，包括字符串型(string)，数字型(number)，布尔型(true/false)，空型(null)和object型。</p><pre><code>{    &quot;name&quot;: &quot;Bruce Eckel&quot;,    &quot;age&quot;: 61,    &quot;male&quot;: true,    &quot;representative_books&quot;: [        &quot;Thinking in C++&quot;,        &quot;Thinking in Java&quot;    ],    &quot;job&quot;: {        &quot;company&quot;: &quot;MindView&quot;,        &quot;position&quot;: &quot;CEO&quot;    },    &quot;comment&quot;: null}</code></pre><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a><strong>JavaBean</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其中设置了books和representive_works有不同的key，来考察类库的兼容性。而且comment在这不当做属性，只当做返回json数据中的备注。</p><pre><code>public class Person {    String name;    int age;    boolean male;    String[] books;    Job job;    //构造方法，getter,setter省略}class Job {    String company;    String position;    //构造方法，getter,setter省略}</code></pre><hr><h2 id="org-json"><a href="#org-json" class="headerlink" title="org.json"></a><strong>org.json</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;先简单说说org.json的用法吧，他提供的类库十分简单，只有四个常用类一个异常类，其中最为常用的一个类就JSONObject，基本可以用这个类解决比较多的事，org.json的设定是将它里面的类用作存储功能。<br><img src="/2018/10/05/gson/images/json_doucment.jpg" alt="org.json&#39;s document"></p><h3 id="获取Json格式数据"><a href="#获取Json格式数据" class="headerlink" title="获取Json格式数据"></a><strong>获取Json格式数据</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其实利用org.json基本上就像是Map&lt;K,V&gt;一样取值存值而已。</p><p>JSONObject有几个常用的构造方法，那么我先使用JSONObject来进行序列化：</p><pre><code>    //字符串转Json    String jsonStr = &quot;{\&quot;name\&quot;: \&quot;Bruce Eckel\&quot;,\&quot;age\&quot;: 61,\&quot;male\&quot;: true,\&quot;representative_books\&quot;: [\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;: {\&quot;company\&quot;: \&quot;MindView\&quot;,\&quot;position\&quot;: \&quot;CEO\&quot;},\&quot;comment\&quot;: null}&quot;;    JSONObject strJson =new JSONObject(jsonStr);    //传入Json格式字符串    System.out.println(&quot;构造参数为String类：&quot;+strJson);    //Map转Json    Map&lt;String,Object&gt; jsonMap = new HashMap&lt;String,Object&gt;();    jsonMap.put(&quot;name&quot;, &quot;Bruce Eckel&quot;);    jsonMap.put(&quot;age&quot;, 61);    jsonMap.put(&quot;male&quot;, true);    jsonMap.put(&quot;job&quot;, new JSONObject(&quot;{\&quot;company\&quot;: \&quot;MindView\&quot;, \&quot;position\&quot;: \&quot;CEO\&quot;}&quot;));    jsonMap.put(&quot;representative_books&quot;, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;});    jsonMap.put(&quot;comment&quot;,null);    JSONObject mapJson = new JSONObject(jsonMap);   //传入Map类型              System.out.println(&quot;构造参数为Map类：&quot;  + mapJson);    //JavaBean转Json    Person bruce = new Person(&quot;Bruce Eckel&quot;, 61, true, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;} , new Job(&quot;MindView&quot;, &quot;CEO&quot;));    JSONObject beanJson = new JSONObject(bruce);    //传入Bean类型        System.out.println(&quot;构造参数为Bean类：&quot; + beanJson);    //用无参构造方法传参数的方式    JSONObject jsonObject = new JSONObject();   //无参构造器    jsonObject.put(&quot;name&quot;,&quot;Bruce Eckel&quot;);    jsonObject.put(&quot;age&quot;, 61);    jsonObject.put(&quot;male&quot;, true);    jsonObject.put(&quot;job&quot;, new JSONObject(&quot;{\&quot;company\&quot;: \&quot;MindView\&quot;, \&quot;position\&quot;: \&quot;CEO\&quot;}&quot;));  //此处用的是JSONObject    jsonObject.put(&quot;representative_books&quot;, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;});    jsonObject.put(&quot;comment&quot;, &quot;null&quot;);          //此处输入的是&quot;null&quot;    System.out.println(&quot;构造参数为空：&quot;+jsonObject);</code></pre><p>输出效果如下：</p><blockquote><p>构造参数为String类：{“name”:”Bruce Eckel”,”comment”:null,”representive_works”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><blockquote><p>构造参数为Map类：{“name”:”Bruce Eckel”,”representive_work”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><blockquote><p>构造参数为Bean类：{“books”:[“Thinking in C++”,”Thinking in Java”],”gender”:true,”name”:”Bruce Eckel”,”job”:{},”age”:61}</p></blockquote><blockquote><p>构造参数为空：{“representive_work”:[“Thinking in C++”,”Thinking in Java”],”name”:”Bruce Eckel”,”comment”:”null”,”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><p><strong>可见JSONObject来进行序列化有如下几点缺陷</strong>：</p><ol><li>得到的Json数据是无序的；</li><li>无论是Map还是JSONObject的put()方法都没办法直接放null值否则会被省略不作序列化；</li><li>JavaBean中的自定义类型属性无法被序列化。</li></ol><p><strong>对于第一点的解决方法</strong>：<br>org.json提供了一个有序的类JSONStringer，用法如下</p><pre><code>    JSONStringer jsonStringer = new JSONStringer();    jsonStringer.object();        jsonStringer.key(&quot;name&quot;);        jsonStringer.value(&quot;Bruce Eckel&quot;);        jsonStringer.key(&quot;age&quot;);        jsonStringer.value(61);        jsonStringer.key(&quot;male&quot;);        jsonStringer.value(true);;        jsonStringer.key(&quot;job&quot;);        jsonStringer.object();            jsonStringer.key(&quot;company&quot;);            jsonStringer.value(&quot;MindView&quot;);            jsonStringer.key(&quot;position&quot;);            jsonStringer.value(&quot;CEO&quot;);        jsonStringer.endObject();        jsonStringer.key(&quot;representative_works&quot;);        jsonStringer.array();            jsonStringer.value(&quot;Thinking in C++&quot;);            jsonStringer.value(&quot;Thinking in Java&quot;);        jsonStringer.endArray();        jsonStringer.key(&quot;comment&quot;);        jsonStringer.value(&quot;null&quot;);    jsonStringer.endObject();    System.out.println(jsonStringer.toString());</code></pre><p>输出效果如下</p><blockquote><p>{“name”:”Bruce Eckel”,”age”:61,”male”:true,”job”:{“company”:”MindView”,”position”:”CEO”},”representative_works”:[“Thinking in C++”,”Thinking in Java”],”comment”:”null”}</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然是麻烦了点(非常麻烦)…毕竟他是有序的。而且一般情况用JSONObject也是够的因为有序不一定有用，而且JSONStringer虽然较为麻烦，但是他对于多重嵌套的问题有很大帮助。但要注意object()和endObject()、array()和endArray()，一定要匹配，否则就会抛出JSONException异常。</p><p><strong>对于第二点的解决方法</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;JSONObject对于null的识别是有坑的，想要赋予值为空的属性时得以”null”的方式传入（可以参考上述无参的构造方式中传”null”的方法-第29行。）<br>那么问题来了，如果想传值为”null”的字符串怎么办？<br>那可能只能通过直接处理字符串的方式了：</p><pre><code>    jsonObject.toString.replaceAll(&quot;:null,&quot;, &quot;:\&quot;null\&quot;,&quot;) </code></pre><p><strong>对于第三点的解决方法</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;org.json库无法识别自定义属性，所以只好用嵌套的方式，即JSONObject里包含JSONObject的方式来代替。（可以参考上述无参构造方式中的job-第27行)</p><h3 id="获取Json的属性值"><a href="#获取Json的属性值" class="headerlink" title="获取Json的属性值"></a><strong>获取Json的属性值</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这里用回之前的JSONObject。org.json压根就没做反序列化，如果手动来做的话这样是比较快的方法了，如果不是为了演示用法真不想做一次，对比起任何一个类库即使是json-lib都比他方便多了。当然，如果你只是为了取得里面的部分数据绝对是可以使用org.json的。</p><pre><code>    String jsonStr = &quot;{\&quot;name\&quot;: \&quot;Bruce Eckel\&quot;,\&quot;age\&quot;: 61,\&quot;male\&quot;: true,\&quot;representive_works\&quot;: [\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;: {\&quot;company\&quot;: \&quot;MindView\&quot;,\&quot;position\&quot;: \&quot;CEO\&quot;},\&quot;comment\&quot;: null}&quot;;    JSONObject strJson =new JSONObject(jsonStr);    // 传入字符串    JSONArray jsonArray = strJson.getJSONArray(&quot;representive_works&quot;);    List&lt;String&gt; lists = new ArrayList&lt;String&gt;();    for (int i = 0; i &lt; jsonArray.length(); i++) {        lists.add(i,jsonArray.optString(i));    }    String[] books = new String[2];    lists.toArray(books);    Job job = new Job(strJson.getJSONObject(&quot;job&quot;).getString(&quot;company&quot;), strJson.getJSONObject(&quot;job&quot;).getString(&quot;position&quot;));    Person bruce = new Person(strJson.getString(&quot;name&quot;),strJson.getInt(&quot;age&quot;),strJson.getBoolean(&quot;male&quot;), books, job);    System.out.println(bruce.name+&quot; &quot;+bruce.age+&quot; &quot;+bruce.male+&quot; &quot;+bruce.books[0]+&quot; &quot;+bruce.books[1]+&quot; &quot;+bruce.job.company+&quot; &quot;+bruce.job.position);</code></pre><p>输出效果如下</p><blockquote><p>Bruce Eckel 61 true Thinking in C++ Thinking in Java MindView CEO</p></blockquote><p>以上就是基本的org.json类库的使用方法了，当然还有像JsonTokener和JSONWritter之类的类，都是没什么必要的，基本用JSONObject、JSONStringer、JSONArray这几个类可以完成业务。这也是org.json轻便之处，如果只是少量的Json操作，那用org.json这种轻量级类库再适合不过了。</p><hr><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a><strong>Gson</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Gson中最重要的类可能就是Gson类了，但Gson中是不像其他类那样以JSONObject这样像Map一样的类存储数据的，Gson相当于只为了使用其成员方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;在操作之前，记得前面设计数据key和JavaBean属性时名字有不同的吗？序列化时如果不作任何操作只会用回原来属性名，而Gson给出了用注解的方式来处理的方法：</p><pre><code>    @SerializedName(value = &quot;representative_books&quot;)</code></pre><p><img src="/2018/10/05/gson/images/json_anno.png" alt="Annotation to change SerializedName "><br>&nbsp;&nbsp;&nbsp;&nbsp;那么在序列化时就会给他自动命名为”representative_books”，反序列化的时候就自动识别key为”representative_books”的语句</p><hr><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h3><p><em>序列化就是将JavaBean到Json字符串的过程</em></p><pre><code>        Person bruce = new Person(&quot;Bruce Eckel&quot;, 61, true, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;} , new Job(&quot;MindView&quot;, &quot;CEO&quot;));        Gson gson = new Gson();        String json = gson.toJson(bruce);        System.out.println(json);</code></pre><p>输出效果</p><blockquote><p>{“name”:”Bruce Eckel”,”age”:61,”male”:true,”representative_books”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”}}</p></blockquote><hr><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><strong>反序列化</strong></h3><p><em>反序列化就是将字符串转换成JavaBean的过程</em></p><pre><code>        Gson gson = new Gson();        String json = &quot;{\&quot;name\&quot;:\&quot;Bruce Eckel\&quot;,\&quot;age\&quot;:61,\&quot;male\&quot;:true,\&quot;representative_books\&quot;:[\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;:{\&quot;company\&quot;:\&quot;MindView\&quot;,\&quot;position\&quot;:\&quot;CEO\&quot;},\&quot;comment\&quot;:null}&quot;;        Person bruce = gson.fromJson(json, Person.class);        System.out.println(bruce.getName()+&quot; &quot;+bruce.getAge()+&quot; &quot;+bruce.isMale()+&quot; &quot;+bruce.getBooks()[0]+&quot; &quot;+bruce.getBooks()[1]+&quot; &quot;+bruce.getJob().company+&quot; &quot;+bruce.getJob().position);</code></pre><p>输出效果</p><blockquote><p>Bruce Eckel 61 true Thinking in C++ Thinking in Java MindView CEO</p></blockquote><hr><h3 id="获取Json数据"><a href="#获取Json数据" class="headerlink" title="获取Json数据"></a><strong>获取Json数据</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;看到这里可能就会说，org.json的前面两点实际上跟Gson的序列化反序列化不太一样吧，org.json是获取数据，Gson是直接序列化了，那如果我只是要获取数据Gson还得创一个JavaBean不更加麻烦吗？实际上是不一定要JavaBean的，相信谷歌设计者也不会这么蠢。<br>&nbsp;&nbsp;&nbsp;&nbsp;Gson作为Json的神器，也有一套类似的方法。但此前先说一些概念性的东西：</p><ol><li>Gson中也有一个叫JsonObject的类，跟之前org.json无论是名字（前面的是JSONObject）还是用处都很像（都是用来存储数据），但还是有不一样的地方。</li><li>Gson的JsonObject也支持通过Json字符串或者用addpProperty()方法（相当于前面JSONObject的put方法）来构建，因为麻烦第二种就不再演示了，大家可以自己去试一下。</li><li>存在JsonObject里的数据称为JsonElement，而JsonElement有四种类型（意思就是说这四个类都是继承于JsonElement的）：JsonPrimitive（相当于number或者string或者boolean)、JsonArray（任意类型的JsonElement的集合，也可以混合类型）、JsonNull（相当于null）、JsonObject（嵌套自己类型），更多的详情请麻烦看下面的例子吧：</li></ol><pre><code>    String json = &quot;{\&quot;name\&quot;:\&quot;Bruce Eckel\&quot;,\&quot;age\&quot;:61,\&quot;male\&quot;:true,\&quot;representative_books\&quot;:[\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;:{\&quot;company\&quot;:\&quot;MindView\&quot;,\&quot;position\&quot;:\&quot;CEO\&quot;},\&quot;comment\&quot;:null}&quot;;    JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject();    System.out.println(jsonObject.getAsJsonPrimitive(&quot;name&quot;));    System.out.println(jsonObject.getAsJsonArray(&quot;representative_books&quot;));    System.out.println(jsonObject.getAsJsonObject(&quot;job&quot;));</code></pre><p>输出效果如下</p><blockquote><p>“Bruce Eckel”<br>[“Thinking in C++”,”Thinking in Java”]<br>{“company”:”MindView”,”position”:”CEO”}</p></blockquote><p>而通过debug以上代码，效果如下图<br><img src="/2018/10/05/gson/images/json_element.png" class="[png]" title="The types of JsonElement"><br>从这里就能很清晰的看到Gson提供的JsonObject的用法和其类型的解释了。可见Gson对于Json数据获取也是比较方便的。</p><hr><h2 id="可见Gson的优势"><a href="#可见Gson的优势" class="headerlink" title="可见Gson的优势"></a>可见Gson的优势</h2><ol><li>解决了null的歧义问题，当序列化的时候，如果对象的某个字段为null，是不会输出到Json字符串中的。当反序列化的时候，某个字段在Json字符串中找不到对应的值，就会被赋值为null。</li><li>自定义类型自动转换，且利用注解能支持字段过滤，支持任意的复杂对象转换。</li><li>代码量明显大幅度减少。</li><li>定义了一套Json数据类型，能够生成可压缩和可读的Json的字符串输出。</li></ol><hr><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在这里已经大致说完org.json和Gson的基本用法和介绍了，但真的仅仅是基本用法，其实Gson还有更多的像自定义Gson配置，各种注解过滤等等，不过对于简单的Json数据转换已经比较足够去应用了。<br>&nbsp;&nbsp;&nbsp;&nbsp;用了Gson之后对比起org.json，肉眼可见的代码量减少，而且在反序列化时对类型也毫无阻碍，不用换来换去。但是单纯是这一点点使用例子与介绍的话实际上很难完全展示出Gson全部魅力，这也仅仅只是冰山一角。有机会的话会试着写更多Gson的用法吧。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.json.org/" target="_blank" rel="noopener">ABOUT JSON</a></li><li><a href="https://stleary.github.io/JSON-java/" target="_blank" rel="noopener">org.json DOCUMENT</a></li><li><a href="https://blog.csdn.net/u013075699/article/details/77964344" target="_blank" rel="noopener">JSONOBJECT NULL SOLUTION</a></li><li><a href="https://github.com/google/gson/blob/master/UserGuide.md" target="_blank" rel="noopener">GSON USER GUIDE</a></li><li><a href="http://tool.oschina.net/apidocs/apidoc?api=gson2.2.2" target="_blank" rel="noopener">GSON DOCUMENT</a></li><li><a href="https://blog.csdn.net/vickyway/article/details/48157819" target="_blank" rel="noopener">COMPARISON AMONG JSON LIBRARY</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Welcome to White Noise</title>
      <link href="/2018/09/28/white-noise/"/>
      <url>/2018/09/28/white-noise/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;Welcome to <a href="https://chitoseyono.github.io/" target="_blank" rel="noopener">White Noise - Chitose Yono Offical Blog</a>! The website is still in constructing and after a while you can enjoy my articles here. Though whether they’re writen in English or Chinese depends on my heart, maybe most of time there is Chinese version.</p><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><h3 id="Todo-list"><a href="#Todo-list" class="headerlink" title="Todo-list"></a>Todo-list</h3><ul><li>Navigator for articles √</li><li>Music bar √</li><li>Original background images for changing √</li><li>Domain binding for the blog √</li><li>Pin to top √</li><li>Gallery</li><li>Categories</li><li>After all of these finished, I’ll make a conclusion.</li></ul><h3 id="Chitose-Yono"><a href="#Chitose-Yono" class="headerlink" title="Chitose Yono"></a>Chitose Yono</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;An undergraduate majoring in Software Programing. Got a lot of interests including music, art, traveling and so on, so don’t expect such a introvert guy will fill the blog with barely programing.</p><h3 id="White-Noise"><a href="#White-Noise" class="headerlink" title="White Noise"></a>White Noise</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Article in <a href="https://chitoseyono.github.io/" target="_blank" rel="noopener">White Noise</a> will be include but not limited to</p><ul><li>Software programing</li><li>Music making</li><li>Vomit machine</li></ul><h3 id="Vomit-machine"><a href="#Vomit-machine" class="headerlink" title="Vomit machine"></a>Vomit machine</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;To talk about the surrounding naraku everyday just like vomitting the shit, so you may have to taste the fucking emotional words in it.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
