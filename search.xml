<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java线程（二）——线程的介绍与创建</title>
      <link href="/2018/10/21/thread/"/>
      <url>/2018/10/21/thread/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><em>11.9已更新：ThreadPoolExecutor</em><br><em>这一篇作为Java线程系列的开篇吧，简单的介绍一下一些普遍的线程和线程的创建方式。</em></p><hr><h1 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h1><p>先放一张随处可见的线程状态转换图：<br><img src="/2018/10/21/thread/images/status.jpg" alt="Thread status"><br>所以啥是线程？<br>平时我们用的程序他运行起来了，他就叫进程（运行中的程序），是一个动态的概念，<br>而进程内部可能包含很多顺序执行任务，那这每一个任务就是一个线程。<br>进程和线程很类似，但又区别很大：</p><p>相同点：</p><ul><li><strong>进程的存在是为了让操作系统同时运行多个程序；线程的存在是为了让进程同时执行多个任务。</strong></li><li><strong>他们都可以并发执行</strong></li></ul><p>区别：</p><ul><li><strong>对于每一个进程系统都会分配一定内存空间与资源，而这些分配的内存空与资源在不同进程之间是很难共享的，所以说进程是地址独立、资源独立的；而对于每一个线程，他们只能共享进程中的资源，尤其是CPU（线程只有获得CPU才能够执行，说到底CPU也是系统分配给进程的）</strong></li><li><strong>一个程序至少要有一个进程，一个进程至少要有一个线程</strong></li></ul><p>为什么使用线程？</p><ul><li><strong>线程之间能共享资源，共享内存十分容易，而进程不行！</strong></li><li><strong>创建线程代价比创建进程要小得多，所以用多线程来实现多任务并发比多进程效率要高。</strong></li></ul><hr><h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><p>除了众所周知的直接继承于Thread和实现Runnable的方法以外，还有Java 5后提供的Future+Callable和线程池，在这里写一下他们的方式与区别。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>直接通过继承于Thread的方式来创建：</p><ol><li>需要一个继承于Thread的类，并重写其中的run()方法</li><li>新建该类的对象</li><li>通过该对象的start()启动线程<pre><code>public class TestThread extends Thread{private int i ;//线程体@Overridepublic void run() {    for( ; i &lt;100 ; i++){       System.out.println(getName()+&quot; &quot;+i);    }}public static void main(String[] args) {    new TestThread().start();    new TestThread().start();}}</code></pre>此时输出的效果部分如下：<blockquote><p>Thread-1 42<br>Thread-0 66<br>Thread-0 67<br>Thread-1 43<br>Thread-1 44<br>Thread-0 68<br>Thread-1 45<br>Thread-0 69</p></blockquote></li></ol><p>可以看见，两个线程都混杂在一起，谁也不能影响到谁的变量i，这是以继承的方式。</p><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>Runnable的定义可以理解为该方法的反型封装，即它执行能做的事情。Runnable的创建线程的方式：</p><ol><li>需要一个实现Runnable的类，并实现其中的run()方法</li><li>创建这个类的实例，作为参数创建一个新的Thread对象</li><li>通过该对象的start()启动线程<pre><code>public class TestRunnable implements Runnable{//共用的成语属性private int i;//实现Runnable的run方法，线程体public void run() {    for (; i &lt; 100; i++) {        System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);    }}public static void main(String[] args) {    TestRunnable tr = new TestRunnable();       //创建Runnable实例    new Thread(tr,&quot;Runnable-Thread1&quot;).start();  //传参构建Thread    new Thread(tr,&quot;Runnable-Thread2&quot;).start();}}</code></pre>部分输出效果：<blockquote><p>Runnable-Thread1 33<br>Runnable-Thread2 34<br>Runnable-Thread1 35<br>Runnable-Thread2 36<br>Runnable-Thread2 38<br>Runnable-Thread2 39<br>Runnable-Thread2 40<br>Runnable-Thread2 41<br>Runnable-Thread1 37</p></blockquote></li></ol><p>显然Thread1和Thread2明显共用了属性i，可见，当两个两个线程同时以同一个Runnable的实现类作为参数的时候，他们能共用那个Runnable的属性。（当然要是你创建两个Runnable实例效果会跟Thread一样，但是那样就没用Runnable的意义了）<br>但因为getName()是Thread类里的方法，所以必须用Thread的静态方法Thread.currentThread()先获得当前线程对象才能调用getName()。</p><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>Callable创建线程的方式跟Runnable很类似，虽然Thread的构造方法参数没有Callable类参数，但FutureTask实现了Runnable接口：</p><ol><li>需要一个实现Callable的类（Callable的泛型就是返回值的类型），并实现其中的call()方法</li><li>创建这个类的实例，作为参数包装成一个新的FutureTask对象</li><li>FutureTask作为参数创建一个新的Thread对象</li><li>通过该对象的start()启动线程</li><li><p>通过get()可以获得返回值（记得捕获异常）</p><pre><code>public class TestCallable implements Callable&lt;Integer&gt; {private int i;//线程体@Overridepublic Integer call(){    for(; i &lt; 100 ; i++){        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);    }    return i;}public static void main(String[] args) {    TestCallable tc = new TestCallable();       //创建Callable实例    FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(tc);        //包装成FutureTask    new Thread(task,&quot;Callable-Thread&quot;).start();             //当target传参进去    try {        System.out.println(&quot;返回值：&quot;+task.get());    } catch (Exception e) {        e.printStackTrace();    }}}</code></pre><p>部分输出效果：</p><blockquote><p>Callable-Thread 96<br>Callable-Thread 97<br>Callable-Thread 98<br>Callable-Thread 99<br>返回值：100</p></blockquote></li></ol><p>虽然用Callable创建起来比Runnable要复杂，但从这里可以看出来了：利用Callable不仅可以抛出异常，而且可以通过get()方法获得线程执行返回的信息。<br>其次要注意的是，这里我没有创建两个线程，只有一个主线程和一个Callable的线程，是因为使用同一个FutureTask来创建线程会被认为是“不安全的”，在Callable的线程体call()执行一次之后会将status改成不再是NEW，而不是NEW的callable将直接退出，无法执行线程体：</p><pre><code>public void run() {    if (state != NEW ||        !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread()))    return;</code></pre><p>所以如果用像前面Runnable那样用一个target创建两个线程的话，第二个线程将会在执行线程体之前就挂掉。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池Java5在之前只能自己手动去创建，现在已经有了多种方法如Executors工厂，ForkJoinPool，在这里先写Executors工厂类吧，利用线程池的方式：</p><ol><li>先调用Executors静态工厂方法创建一个ExecutorService或ScheduledExecutorService线程池对象（创建时可传入ThreadFactory来进行规定创建线程，下面CacheThreadPool会有例子）</li><li>创建Runnable/Callable实例，利用线程池对象的execute()和submit()或者schedule()来传入线程池并执行（callable必须用submit())</li><li>当任务完成后，执行shutdown()来关闭线程池</li></ol><p>附上一张线程池状态图：<br><img src="/2018/10/21/thread/images/poolstatus.jpg" alt="Thread Pool Status"></p><blockquote><p>其中newCacheThreadPool(), newFixedThreadPool(int nThreads), newSingleThreadExecutor()是ExecutorService对象，而newScheduledThreadPool(int corePoolSize), newSingleScheduledThreadPool()为ScheduledExecutorService对象，下面我会为前三个常用的做简单的例子。</p></blockquote><p>###<strong>FixedThreadPool</strong>：</p><pre><code>    public class PoolTest {        static class PoolRunnable implements Runnable{            private int i;            public void run() {                for (; i &lt; 100; i++) {                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + i);                }            }        }        public static void main(String[] args) {            ExecutorService executorService = Executors.newFixedThreadPool(3);            PoolRunnable p = new PoolRunnable();            executorService.execute(p);            executorService.submit(p);            executorService.shutdown();        }    }</code></pre><p>部分输出效果：</p><blockquote><p>pool-1-thread-1 41<br>pool-1-thread-2 45<br>pool-1-thread-1 46<br>pool-1-thread-2 47<br>pool-1-thread-2 49<br>pool-1-thread-2 50<br>pool-1-thread-2 51<br>pool-1-thread-2 52<br>pool-1-thread-1 48<br>pool-1-thread-2 53<br>pool-1-thread-1 54</p></blockquote><p>可见与用Runnable的方式效果相差无几，只是方式不一样了而已。<br>而三种Executor都有他们特别的地方，用<em>Thinking in Java</em>的原话来说的话就是这样：</p><blockquote><p>CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程的时候停止创建新线程，因此它是合理的Executor首选。只有在这种方式会引发问题的时候，才需要用到FixedThreadPool。<br>FixedThreadPool可以一次性预先执行代价高昂的线程分配，然后限制现成的数量不用每个任务都要付出创建线程的开销，直接从池中获取线程，且不会滥用可获得的资源。<br>SingleThreadExecutor就像是数量为1的FixedThreadPool，如果向它提交了多个任务，这些任务都将排队，所有任务将使用同一个进程。（但还是有区别，他提供了一种重要的并发保证，保证不会有两个线程被并发调用）</p></blockquote><p>###<strong>SingleThreadExecutord</strong>：</p><pre><code>public class PoolTest2 {    static class PoolRunnable2 implements Runnable{        public void run() {            int random = (int) Math.round(Math.random()*9+1);            System.out.println(&quot;我是&quot;+Thread.currentThread().getName()+&quot;, 我先睡&quot;+random+&quot;秒&quot;);            try {                Thread.sleep(random*1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName()+&quot;已经溜了&quot;);        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newSingleThreadExecutor();//换成newCachedThreadPool试试        for(int i = 0 ; i &lt; 5 ; i++) {            PoolRunnable2 p = new PoolRunnable2();            executorService.execute(p);        }        executorService.shutdown();    }}</code></pre><p>效果如图：</p><blockquote><p>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡7秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡6秒<br>pool-1-thread-1已经溜了<br>我是pool-1-thread-1, 我先睡5秒<br>pool-1-thread-1已经溜了</p></blockquote><p>可见该线程池中始终只有一个线程，一直使用的也是那一个线程。</p><p>###<strong>CacheThreadPool</strong><br>在利用线程池创建线程的时候我们很容易发现，几种创建线程池的方式都可以传入类型为ThreadFactory的参数，实际上线程池默认会有一个ThreadFactory的成员属性，当我们不传这个参数时默认为Executors.defaultThreadFactory()，里面包含了他所规定的创建线程时的操作：</p><pre><code>    static class DefaultThreadFactory implements ThreadFactory {        private static final AtomicInteger poolNumber = new AtomicInteger(1);        private final ThreadGroup group;        private final AtomicInteger threadNumber = new AtomicInteger(1);        private final String namePrefix;        DefaultThreadFactory() {            SecurityManager s = System.getSecurityManager();            group = (s != null) ? s.getThreadGroup() :                                  Thread.currentThread().getThreadGroup();            namePrefix = &quot;pool-&quot; +                          poolNumber.getAndIncrement() +                         &quot;-thread-&quot;;        }        public Thread newThread(Runnable r) {            Thread t = new Thread(group, r,                                  namePrefix + threadNumber.getAndIncrement(),                                  0);            if (t.isDaemon())                t.setDaemon(false);            if (t.getPriority() != Thread.NORM_PRIORITY)                t.setPriority(Thread.NORM_PRIORITY);            return t;        }    }</code></pre><p>那么我们实际上也可以定义一个自己的ThreadFactory来<strong>定义线程池在创建线程时候的操作（这就是ThreadFactory的作用）</strong>。<br>在这里既然讲到了ThreadFactory，那么也顺带讲一讲线程的异常捕获吧。线程的异常由于线程的本质特性，使得不能捕获到线程中逃逸的异常（你大可以尝试在run中抛出一个异常，然后在main中尝试去捕获它），在Java SE5以前只能使用线程组进行捕获<del>（而线程组已被Sun公司的架构师表示——“最好把线程组看成是一次不成功的尝试，你只要忽略它就行了”）</del>，而Java SE5线程池的出现已经能完美的解决这一问题。<br>我们通过前面所提到的ThreadFactory能修改线程池生产线程的方式——在生产时候为每个Thread对象附上一个异常处理器UncaughtExceptionHandler，那么在抛出异常的时候便会通过处理器进行捕获处理：</p><pre><code>public class PoolTest3 {    static class ExecptionThread implements Runnable{        @Override        public void run() {            throw new RuntimeException();        }    }    static class EHThreadFactory implements ThreadFactory{        @Override        public Thread newThread(Runnable r) {            Thread t = new Thread(r);            t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {                @Override                public void uncaughtException(Thread t, Throwable e) {                    System.out.println(&quot;catch &quot; + e);                }            });//你也可以创建一个类继承于Thread.UncaughtExceptionHandler来进行使用而不使用匿名类            return t;        }    }    public static void main(String[] args) {        ExecutorService executorService = Executors.newCachedThreadPool(new EHThreadFactory());        executorService.execute(new ExecptionThread());        executorService.shutdown();    }}</code></pre><p>效果如下</p><blockquote><p>catch java.lang.RuntimeException</p></blockquote><p>你甚至可以调用静态设置Thread.setDefaultUncaughtExceptionHandler()来让所有没有设置未捕获异常处理器的线程调用默认的未捕获异常处理器。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><strong>ThreadPoolExecutor</strong></h3><p>我们已经知道是通过工厂方法来创建的线程池，那那些线程池实际上都是什么？<br>只要你看了看源代码就知道，无论是创建Fixed的还是Cached的线程池，其实都是new 一个 ThreadPoolExecutor(但是是ExecutorService的实现，具体可看下图），只是他们new出的ThreadPoolExecutor参数不同。</p><p>如图可见他们的关系：<br><img src="/2018/10/21/thread/images/relation.jpg" alt="relation"></p><p>而他有以下几个核心参数用于初始化：</p><p>corePoolSize：核心线程数<br>maximumPoolSize：最大线程数<br>workQueue：阻塞队列，存储等待执行的任务，有三种<br>keepAlive：线程没有任务时最多保持多久才终止（单位为unit）<br>threadFactory：线程工厂，用来设置线程池生产线程的方式<br>rejectHandler：拒绝任务的时候的策略</p><p>他有几个可用于监控的重要方法：</p><p>getTaskCount()：获得线程池已执行和未执行的任务总数<br>getCompletedTaskCount()：获得以完成的任务数量<br>getPoolSize()：线程池中当前线程的数量<br>getActiveCount()：当前线程池中正在执行任务的线程数量</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>直接用Thread的方式创建多线程的优势：</p><p><strong>编程简单，像获得当前线程直接通过实例的方法即可，十分适合那些短小精悍的线程。</strong></p><p>用实现Runnable的方式创建多线程的优势：</p><p> <strong>1.能继承与实现更多的类</strong><br> <strong>2.能通过共用target来进行共享资源</strong></p><p>用实现Callable的方式创建多线程的优势：</p><p> <strong>1.能继承与实现更多的类</strong><br> <strong>2.能捕获异常进行处理</strong><br> <strong>3.能获得线程执行的返回值，在编程上能有更多空间</strong></p><p>用线程池的方式的优势：</p><p><strong>1.target通过submit()或schedule()传入线程池后，线程池会启用一个线程来执行target里的run()或call(),但执行结束后不会死亡，将进入空闲状态保留在线程池中，等待下一个target时使用。这样在创建大量的短暂线程的时候可以不用像Thraed那样用一个创建一个，性能差又浪费资源，直接从线程池中使用。</strong><br><strong>2.可以通过控制线程池的最大线程数来控制系统并发线程数，统一管理线程，防止线程创建过多占用过多系统资源而导致的JVM崩溃，也避免的资源竞争</strong><br><strong>3.利用ScheduledExecutorService能指定延迟或周期性的执行线程任务</strong><br><strong>4.集合Runnable和Callable的优点——能共享资源，能处理返回值等</strong><br><strong>5.使用Executor能明显感到线程与任务是不同的概念，因为它甚至替你创建与管理线程，他将用户提交与运行分离开来，当然你也可以通过ThreadFactory来自定义线程池中线程的创建方式</strong></p><hr><p><em>本篇还未更新完，下一篇会写线程的控制相关</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HttpURLConnection和HttpClient简单上手</title>
      <link href="/2018/10/14/http-easy/"/>
      <url>/2018/10/14/http-easy/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;最近做项目过程中要搞HTTP请求的时候总是只能用以前写好的URLUtil，略是僵硬，想起之前做安卓有用过okhttp和httpclient，试着在Java里用一用并对比一下他们的效果吧。本章代码已上传<a href="https://github.com/ChitoseYono/HttpUtil" target="_blank" rel="noopener">github</a>。</p><hr><h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;原生Java自带的http请求方式，抽象类URLConnection是表示应用程序和URL之间的通信链接的所有类的超类。 该类的实例可以用于从URL引用的资源中读取和写入。而HttpURLConnection是最常用于进行Http链接的他的子类。<br>请求方式一般步骤（参考JDK文档）：</p><ol><li>通过在URL上调用openConnection方法创建连接对象。</li><li>设置参数和一般请求属性。 </li><li>使用connect方法实现与远程对象的实际连接。</li><li>远程对象变得可用。 可以访问头字段和远程对象的内容。</li></ol><h3 id="简单GET请求"><a href="#简单GET请求" class="headerlink" title="简单GET请求"></a>简单GET请求</h3><pre><code>        public String getByConnection(String str) throws IOException {        //1.创建连接        URL url = new URL(str);        HttpURLConnection httpConn = (HttpURLConnection)url.openConnection();        //2.设置参数        httpConn.setRequestMethod(&quot;GET&quot;);       //请求类型        httpConn.setRequestProperty( &quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot; );  //请求属性        httpConn.setConnectTimeout(100000);     //连接超时时间        httpConn.setReadTimeout(100000);        //读取超时时间        httpConn.setDoInput(true);              //是否读入        httpConn.setDoOutput(true);             //是否输出        httpConn.setUseCaches(true);            //是否使用缓存        //3.连接        httpConn.connect();                     //其实会调用所以不必要用connect()        //4.访问连接内容        BufferedReader reader = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));        String line;        StringBuffer buffer = new StringBuffer();        while ((line = reader.readLine()) != null) {            buffer.append(line);        }        reader.close();        httpConn.disconnect();        return buffer.toString();    }</code></pre><h3 id="进行上传文件"><a href="#进行上传文件" class="headerlink" title="进行上传文件"></a>进行上传文件</h3><p>之所以不写Post原因是上传文件实际上就是一种特殊的POST，只是比简单的POST要多上不少东西，对于简单的POST可以只是向连接的OutputStream中写入键值对便可以了（跟get没什么区别的话也没太多必要用POST)。</p><p>首先由于HttpURLConnection的局限性（他只是一个抽象类，没有什么特别的集成），对于上传文件这类”multipart/form-data”类型的请求类型只能由我们手动拼接Header <del>（我来组成头部！）</del>，所以在说如何用HttpURLConnection进行上传文件前先说说上传时的Header：<br><img src="/2018/10/14/http-easy/images/header.png" alt="Http Header"><br>可见在这用POST上传图片实际上就是模拟表单上传，而这时需要有拼接请求体：</p><ol><li>请求体中需要先以”—–一串随机数字(代码中用的是UUID的随机序列)\r\n(\r\n的作用是换行)”来上下分隔。所以在前后都要加上boundary</li><li>然后写入Content-Disposition:form-data;name=”<strong>(此处需要与服务器约定)</strong>“;filename=”<strong>文件名</strong>“;</li><li>通过InputStream写入HttpURLConnection的OutputStream中。</li><li><p>最后以”—–那一串数字–\r\n”结尾。</p><pre><code>public String uploadByConnection(String str) throws IOException{    //1.创建连接    URL url = new URL(str);    HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();    //2.设置参数    String Boundary = UUID.randomUUID().toString();     //请求边界    httpConn.setRequestMethod(&quot;POST&quot;);                  //请求类型    httpConn.setRequestProperty(&quot;Charset&quot;, &quot;utf-8&quot;);    //请求属性    httpConn.setRequestProperty( &quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot;+Boundary );       //请求属性    httpConn.setConnectTimeout(100000);     //连接超时时间    httpConn.setReadTimeout(100000);        //读取超时时间    httpConn.setDoInput(true);              //是否读入    httpConn.setDoOutput(true);             //是否输出    httpConn.setUseCaches(true);            //是否使用缓存    //3.HTTP请求体    DataOutputStream out = new DataOutputStream(httpConn.getOutputStream());    out.writeUTF(&quot;Content-Disposition: form-data; name=\&quot;user_upload_icon\&quot;; filename=\&quot;foo.jpg\&quot;\r\n\r\n&quot;);    InputStream in = new FileInputStream(&quot;src/foo.jpg&quot;);    byte[] b = new byte[1024];    int l = 0;    while((l = in.read(b)) != -1) out.write(b,0,l); // 写入文件    out.writeUTF(&quot;\r\n--&quot;+Boundary+&quot;--\r\n&quot;);    out.flush();    out.close();    in.close();    //4.获取响应信息    BufferedReader reader = new BufferedReader(new InputStreamReader(httpConn.getInputStream()));    String line;    StringBuffer buffer = new StringBuffer();    while ((line = reader.readLine()) != null) {        buffer.append(line);    }    reader.close();    httpConn.disconnect();    return buffer.toString();}</code></pre></li></ol><hr><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;作为Apache下手开发的工具包，使用起来比JDK自带的更为轻松和简单，实现的功能也更多。<br>HttpCLient最关键的方法是执行HTTP请求的方法execute。只要把HTTP请求传入，就可以得到HTTP响应。<br>使用HttpClient请求一个Http请求的步骤为：</p><ol><li>创建一个HttpClient对象</li><li>创建一个Request对象</li><li>使用HttpClient来执行Request请求，得到对方的response</li><li>处理response</li><li>关闭HttpClient</li></ol><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;  &lt;artifactId&gt;httpclient&lt;/artifactId&gt;  &lt;version&gt;4.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpmime&lt;/artifactId&gt;    &lt;version&gt;4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><pre><code>compile &#39;org.apache.httpcomponents:httpclient:4.5.6&#39;</code></pre><h3 id="简单的GET请求"><a href="#简单的GET请求" class="headerlink" title="简单的GET请求"></a>简单的GET请求</h3><pre><code>public String getByClient(String str) throws IOException {    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(1000).build();   //可以对请求进行各种配置    HttpGet httpGet = new HttpGet(str);                             //创建Get请求    httpGet.setConfig(requestConfig);                               //设置配置    CloseableHttpResponse response = client.execute(httpGet);       //通过Client执行请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;这绝对是肉眼可见的代码量减少，而且步骤十分清晰。值得一提的是，HttpClient以前的构建方式已经废弃，不能使用了：<br><del>HttpClinet client = new HttpClient();</del></p><h3 id="简单的POST请求"><a href="#简单的POST请求" class="headerlink" title="简单的POST请求"></a>简单的POST请求</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Post请求HttpClient巧妙的设计了HttpEntity类，以它来实现Http请求时的请求体，而且可以以多种方式创建，以便实现各种Post请求如表格，文件等，简单Post请求则可以用简单键值对来创建。</p><pre><code>public static String postByClient(String str, String phone, String password) throws IOException{    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().           //对请求进行各种配置            setConnectTimeout(1000).setConnectionRequestTimeout(1000)            .setSocketTimeout(1000).setRedirectsEnabled(true).build();    List&lt;BasicNameValuePair&gt; list = new ArrayList&lt;BasicNameValuePair&gt;();    //以列表形式创建Post的键值对信息    list.add(new BasicNameValuePair(&quot;phone&quot;,phone));    list.add(new BasicNameValuePair(&quot;password&quot;, password));    UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list,&quot;utf-8&quot;);   //用列表创建表格编码实体    HttpPost httpPost = new HttpPost(str);                          //创建Post请求    httpPost.setConfig(requestConfig);                              //设置配置    httpPost.setEntity(entity);                                     //设置实体信息    CloseableHttpResponse response = client.execute(httpPost);      //执行post请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Post请求上传文件可以利用MultipartEntityBuilder来进行Http请求体的创建，利用addPart(key,body)的形式可以对多形式的value进行记入。</p><pre><code>public static String uploadByClient(String str) throws IOException{    CloseableHttpClient client = HttpClients.createDefault();       //创建HttpClient对象    RequestConfig requestConfig = RequestConfig.custom().           //对请求进行各种配置            setConnectTimeout(1000).setConnectionRequestTimeout(1000)            .setSocketTimeout(1000).setRedirectsEnabled(true).build();    FileBody body = new FileBody(new File(&quot;src/foo.jpg&quot;), ContentType.MULTIPART_FORM_DATA);    HttpEntity entity = MultipartEntityBuilder.create().addPart(&quot;user_upload_icon&quot;,body).build();   //直接用MultipartEntityBuilder创建HTTP实体    HttpPost httpPost = new HttpPost(str);                          //创建Post请求    httpPost.setConfig(requestConfig);                              //设置配置    httpPost.setEntity(entity);                                     //设置实体信息    CloseableHttpResponse response = client.execute(httpPost);      //执行post请求    String result = EntityUtils.toString(response.getEntity());     //处理获得的Http实体    response.close();                                               //关闭各种资源    client.close();    return result;}</code></pre><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这次简单的说了一下HttpURLConnection和HttpClinet的get/post请求方式，而且也很明显比较可见HttpClient集成的东西，帮我们做到的东西。当然HttpClient可以做的事远远不止get/post请求，他还有各种强大的功能在背后，他的设计与效果是十分精湛的。可以参考下面的链接来看关于HttpClient的更多用法与解析。<br>&nbsp;&nbsp;&nbsp;&nbsp;除了HttpURLConnection和HttpClinet以外，还有许多的优秀网络框架，如okhttp，Volley等，在安卓端开发时备受好评。<del>(而且HttpClient在API 23后都不支持使用了）</del>当然像这样轻量级的框架在做简单请求操作的时候是完全足够的，对于其他的框架以后再看吧。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://kb.cnblogs.com/page/92320/" target="_blank" rel="noopener">ABOUT HEADER</a></li><li><a href="http://hc.apache.org/" target="_blank" rel="noopener">HTTPCLIENT</a></li><li><a href="https://blog.csdn.net/u011179993/article/details/47147909" target="_blank" rel="noopener">HTTPCLIENT TUTORIALS</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Json和Gson的介绍与简单使用</title>
      <link href="/2018/10/05/gson/"/>
      <url>/2018/10/05/gson/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。<br>&nbsp;&nbsp;&nbsp;&nbsp;Gson（又称Google Json）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Json的使用大部分人都会知道的一个轻量级库：<a href="https://github.com/stleary/JSON-java" target="_blank" rel="noopener">org.json</a>，现在仍旧有不少人用，不过他对于json格式到bean格式的转换设计的有缺陷而且麻烦（例如复杂类型转换），对于简单的Json序列化操作时如此<strong>轻量级</strong>的类库是个不错的选择。（毕竟轻量级且五脏俱全）<br>&nbsp;&nbsp;&nbsp;&nbsp;如今对于Json的类库比较广为人知的有<a href="http://json-lib.sourceforge.net/index.html" target="_blank" rel="noopener">json-lib</a>、Jackson、阿里巴巴的 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">FastJson</a>、谷歌的 <a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>，json-lib依赖的包太多速度也慢就不提了，虽然FastJson在parseJson有算法上的先进性以至能大大提高其速度运作，而Jackson在速度上也相差不多，但Gson在对于复杂的类型转换上有更强的性能，对于标准化的类库来说，Gson更能被称为Json的神器，那么在本篇我会写关于org.json的简单使用与Gson的常见使用来比较两者的用途与用法。<br>&nbsp;&nbsp;&nbsp;&nbsp;本章代码已上传到<a href="https://github.com/ChitoseYono/JsonTest" target="_blank" rel="noopener">github</a>，可以查看代码自己研究。</p><hr><h2 id="添加类库依赖"><a href="#添加类库依赖" class="headerlink" title="添加类库依赖"></a><strong>添加类库依赖</strong></h2><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><p><strong>org.json</strong>:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.json&lt;/groupId&gt;    &lt;artifactId&gt;json&lt;/artifactId&gt;    &lt;version&gt;20180813&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>Gson</strong>:</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;  &lt;artifactId&gt;gson&lt;/artifactId&gt;  &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a><strong>Gradle</strong></h3><p><strong>org.json</strong>:</p><pre><code>compile group: &#39;org.json&#39;, name: &#39;json&#39;, version: &#39;20180813&#39;</code></pre><p><strong>Gson</strong>:</p><pre><code>dependencies {  implementation &#39;com.google.code.gson:gson:2.8.5&#39;}</code></pre><hr><h2 id="Json数据与Bean"><a href="#Json数据与Bean" class="headerlink" title="Json数据与Bean"></a><strong>Json数据与Bean</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在正式介绍前简单看看本章会用到的Json数据与相应的JavaBean：</p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a><strong>Json</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Json数据例子中简单地囊括Json中所有的类型，包括字符串型(string)，数字型(number)，布尔型(true/false)，空型(null)和object型。</p><pre><code>{    &quot;name&quot;: &quot;Bruce Eckel&quot;,    &quot;age&quot;: 61,    &quot;male&quot;: true,    &quot;representative_books&quot;: [        &quot;Thinking in C++&quot;,        &quot;Thinking in Java&quot;    ],    &quot;job&quot;: {        &quot;company&quot;: &quot;MindView&quot;,        &quot;position&quot;: &quot;CEO&quot;    },    &quot;comment&quot;: null}</code></pre><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a><strong>JavaBean</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其中设置了books和representive_works有不同的key，来考察类库的兼容性。而且comment在这不当做属性，只当做返回json数据中的备注。</p><pre><code>public class Person {    String name;    int age;    boolean male;    String[] books;    Job job;    //构造方法，getter,setter省略}class Job {    String company;    String position;    //构造方法，getter,setter省略}</code></pre><hr><h2 id="org-json"><a href="#org-json" class="headerlink" title="org.json"></a><strong>org.json</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;先简单说说org.json的用法吧，他提供的类库十分简单，只有四个常用类一个异常类，其中最为常用的一个类就JSONObject，基本可以用这个类解决比较多的事，org.json的设定是将它里面的类用作存储功能。<br><img src="/2018/10/05/gson/images/json_doucment.jpg" alt="org.json&#39;s document"></p><h3 id="获取Json格式数据"><a href="#获取Json格式数据" class="headerlink" title="获取Json格式数据"></a><strong>获取Json格式数据</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其实利用org.json基本上就像是Map&lt;K,V&gt;一样取值存值而已。</p><p>JSONObject有几个常用的构造方法，那么我先使用JSONObject来进行序列化：</p><pre><code>    //字符串转Json    String jsonStr = &quot;{\&quot;name\&quot;: \&quot;Bruce Eckel\&quot;,\&quot;age\&quot;: 61,\&quot;male\&quot;: true,\&quot;representative_books\&quot;: [\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;: {\&quot;company\&quot;: \&quot;MindView\&quot;,\&quot;position\&quot;: \&quot;CEO\&quot;},\&quot;comment\&quot;: null}&quot;;    JSONObject strJson =new JSONObject(jsonStr);    //传入Json格式字符串    System.out.println(&quot;构造参数为String类：&quot;+strJson);    //Map转Json    Map&lt;String,Object&gt; jsonMap = new HashMap&lt;String,Object&gt;();    jsonMap.put(&quot;name&quot;, &quot;Bruce Eckel&quot;);    jsonMap.put(&quot;age&quot;, 61);    jsonMap.put(&quot;male&quot;, true);    jsonMap.put(&quot;job&quot;, new JSONObject(&quot;{\&quot;company\&quot;: \&quot;MindView\&quot;, \&quot;position\&quot;: \&quot;CEO\&quot;}&quot;));    jsonMap.put(&quot;representative_books&quot;, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;});    jsonMap.put(&quot;comment&quot;,null);    JSONObject mapJson = new JSONObject(jsonMap);   //传入Map类型              System.out.println(&quot;构造参数为Map类：&quot;  + mapJson);    //JavaBean转Json    Person bruce = new Person(&quot;Bruce Eckel&quot;, 61, true, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;} , new Job(&quot;MindView&quot;, &quot;CEO&quot;));    JSONObject beanJson = new JSONObject(bruce);    //传入Bean类型        System.out.println(&quot;构造参数为Bean类：&quot; + beanJson);    //用无参构造方法传参数的方式    JSONObject jsonObject = new JSONObject();   //无参构造器    jsonObject.put(&quot;name&quot;,&quot;Bruce Eckel&quot;);    jsonObject.put(&quot;age&quot;, 61);    jsonObject.put(&quot;male&quot;, true);    jsonObject.put(&quot;job&quot;, new JSONObject(&quot;{\&quot;company\&quot;: \&quot;MindView\&quot;, \&quot;position\&quot;: \&quot;CEO\&quot;}&quot;));  //此处用的是JSONObject    jsonObject.put(&quot;representative_books&quot;, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;});    jsonObject.put(&quot;comment&quot;, &quot;null&quot;);          //此处输入的是&quot;null&quot;    System.out.println(&quot;构造参数为空：&quot;+jsonObject);</code></pre><p>输出效果如下：</p><blockquote><p>构造参数为String类：{“name”:”Bruce Eckel”,”comment”:null,”representive_works”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><blockquote><p>构造参数为Map类：{“name”:”Bruce Eckel”,”representive_work”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><blockquote><p>构造参数为Bean类：{“books”:[“Thinking in C++”,”Thinking in Java”],”gender”:true,”name”:”Bruce Eckel”,”job”:{},”age”:61}</p></blockquote><blockquote><p>构造参数为空：{“representive_work”:[“Thinking in C++”,”Thinking in Java”],”name”:”Bruce Eckel”,”comment”:”null”,”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><p><strong>可见JSONObject来进行序列化有如下几点缺陷</strong>：</p><ol><li>得到的Json数据是无序的；</li><li>无论是Map还是JSONObject的put()方法都没办法直接放null值否则会被省略不作序列化；</li><li>JavaBean中的自定义类型属性无法被序列化。</li></ol><p><strong>对于第一点的解决方法</strong>：<br>org.json提供了一个有序的类JSONStringer，用法如下</p><pre><code>    JSONStringer jsonStringer = new JSONStringer();    jsonStringer.object();        jsonStringer.key(&quot;name&quot;);        jsonStringer.value(&quot;Bruce Eckel&quot;);        jsonStringer.key(&quot;age&quot;);        jsonStringer.value(61);        jsonStringer.key(&quot;male&quot;);        jsonStringer.value(true);;        jsonStringer.key(&quot;job&quot;);        jsonStringer.object();            jsonStringer.key(&quot;company&quot;);            jsonStringer.value(&quot;MindView&quot;);            jsonStringer.key(&quot;position&quot;);            jsonStringer.value(&quot;CEO&quot;);        jsonStringer.endObject();        jsonStringer.key(&quot;representative_works&quot;);        jsonStringer.array();            jsonStringer.value(&quot;Thinking in C++&quot;);            jsonStringer.value(&quot;Thinking in Java&quot;);        jsonStringer.endArray();        jsonStringer.key(&quot;comment&quot;);        jsonStringer.value(&quot;null&quot;);    jsonStringer.endObject();    System.out.println(jsonStringer.toString());</code></pre><p>输出效果如下</p><blockquote><p>{“name”:”Bruce Eckel”,”age”:61,”male”:true,”job”:{“company”:”MindView”,”position”:”CEO”},”representative_works”:[“Thinking in C++”,”Thinking in Java”],”comment”:”null”}</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然是麻烦了点(非常麻烦)…毕竟他是有序的。而且一般情况用JSONObject也是够的因为有序不一定有用，而且JSONStringer虽然较为麻烦，但是他对于多重嵌套的问题有很大帮助。但要注意object()和endObject()、array()和endArray()，一定要匹配，否则就会抛出JSONException异常。</p><p><strong>对于第二点的解决方法</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;JSONObject对于null的识别是有坑的，想要赋予值为空的属性时得以”null”的方式传入（可以参考上述无参的构造方式中传”null”的方法-第29行。）<br>那么问题来了，如果想传值为”null”的字符串怎么办？<br>那可能只能通过直接处理字符串的方式了：</p><pre><code>    jsonObject.toString.replaceAll(&quot;:null,&quot;, &quot;:\&quot;null\&quot;,&quot;) </code></pre><p><strong>对于第三点的解决方法</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;org.json库无法识别自定义属性，所以只好用嵌套的方式，即JSONObject里包含JSONObject的方式来代替。（可以参考上述无参构造方式中的job-第27行)</p><h3 id="获取Json的属性值"><a href="#获取Json的属性值" class="headerlink" title="获取Json的属性值"></a><strong>获取Json的属性值</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这里用回之前的JSONObject。org.json压根就没做反序列化，如果手动来做的话这样是比较快的方法了，如果不是为了演示用法真不想做一次，对比起任何一个类库即使是json-lib都比他方便多了。当然，如果你只是为了取得里面的部分数据绝对是可以使用org.json的。</p><pre><code>    String jsonStr = &quot;{\&quot;name\&quot;: \&quot;Bruce Eckel\&quot;,\&quot;age\&quot;: 61,\&quot;male\&quot;: true,\&quot;representive_works\&quot;: [\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;: {\&quot;company\&quot;: \&quot;MindView\&quot;,\&quot;position\&quot;: \&quot;CEO\&quot;},\&quot;comment\&quot;: null}&quot;;    JSONObject strJson =new JSONObject(jsonStr);    // 传入字符串    JSONArray jsonArray = strJson.getJSONArray(&quot;representive_works&quot;);    List&lt;String&gt; lists = new ArrayList&lt;String&gt;();    for (int i = 0; i &lt; jsonArray.length(); i++) {        lists.add(i,jsonArray.optString(i));    }    String[] books = new String[2];    lists.toArray(books);    Job job = new Job(strJson.getJSONObject(&quot;job&quot;).getString(&quot;company&quot;), strJson.getJSONObject(&quot;job&quot;).getString(&quot;position&quot;));    Person bruce = new Person(strJson.getString(&quot;name&quot;),strJson.getInt(&quot;age&quot;),strJson.getBoolean(&quot;male&quot;), books, job);    System.out.println(bruce.name+&quot; &quot;+bruce.age+&quot; &quot;+bruce.male+&quot; &quot;+bruce.books[0]+&quot; &quot;+bruce.books[1]+&quot; &quot;+bruce.job.company+&quot; &quot;+bruce.job.position);</code></pre><p>输出效果如下</p><blockquote><p>Bruce Eckel 61 true Thinking in C++ Thinking in Java MindView CEO</p></blockquote><p>以上就是基本的org.json类库的使用方法了，当然还有像JsonTokener和JSONWritter之类的类，都是没什么必要的，基本用JSONObject、JSONStringer、JSONArray这几个类可以完成业务。这也是org.json轻便之处，如果只是少量的Json操作，那用org.json这种轻量级类库再适合不过了。</p><hr><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a><strong>Gson</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Gson中最重要的类可能就是Gson类了，但Gson中是不像其他类那样以JSONObject这样像Map一样的类存储数据的，Gson相当于只为了使用其成员方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;在操作之前，记得前面设计数据key和JavaBean属性时名字有不同的吗？序列化时如果不作任何操作只会用回原来属性名，而Gson给出了用注解的方式来处理的方法：</p><pre><code>    @SerializedName(value = &quot;representative_books&quot;)</code></pre><p><img src="/2018/10/05/gson/images/json_anno.png" alt="Annotation to change SerializedName "><br>&nbsp;&nbsp;&nbsp;&nbsp;那么在序列化时就会给他自动命名为”representative_books”，反序列化的时候就自动识别key为”representative_books”的语句</p><hr><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h3><p><em>序列化就是将JavaBean到Json字符串的过程</em></p><pre><code>        Person bruce = new Person(&quot;Bruce Eckel&quot;, 61, true, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;} , new Job(&quot;MindView&quot;, &quot;CEO&quot;));        Gson gson = new Gson();        String json = gson.toJson(bruce);        System.out.println(json);</code></pre><p>输出效果</p><blockquote><p>{“name”:”Bruce Eckel”,”age”:61,”male”:true,”representative_books”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”}}</p></blockquote><hr><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><strong>反序列化</strong></h3><p><em>反序列化就是将字符串转换成JavaBean的过程</em></p><pre><code>        Gson gson = new Gson();        String json = &quot;{\&quot;name\&quot;:\&quot;Bruce Eckel\&quot;,\&quot;age\&quot;:61,\&quot;male\&quot;:true,\&quot;representative_books\&quot;:[\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;:{\&quot;company\&quot;:\&quot;MindView\&quot;,\&quot;position\&quot;:\&quot;CEO\&quot;},\&quot;comment\&quot;:null}&quot;;        Person bruce = gson.fromJson(json, Person.class);        System.out.println(bruce.getName()+&quot; &quot;+bruce.getAge()+&quot; &quot;+bruce.isMale()+&quot; &quot;+bruce.getBooks()[0]+&quot; &quot;+bruce.getBooks()[1]+&quot; &quot;+bruce.getJob().company+&quot; &quot;+bruce.getJob().position);</code></pre><p>输出效果</p><blockquote><p>Bruce Eckel 61 true Thinking in C++ Thinking in Java MindView CEO</p></blockquote><hr><h3 id="获取Json数据"><a href="#获取Json数据" class="headerlink" title="获取Json数据"></a><strong>获取Json数据</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;看到这里可能就会说，org.json的前面两点实际上跟Gson的序列化反序列化不太一样吧，org.json是获取数据，Gson是直接序列化了，那如果我只是要获取数据Gson还得创一个JavaBean不更加麻烦吗？实际上是不一定要JavaBean的，相信谷歌设计者也不会这么蠢。<br>&nbsp;&nbsp;&nbsp;&nbsp;Gson作为Json的神器，也有一套类似的方法。但此前先说一些概念性的东西：</p><ol><li>Gson中也有一个叫JsonObject的类，跟之前org.json无论是名字（前面的是JSONObject）还是用处都很像（都是用来存储数据），但还是有不一样的地方。</li><li>Gson的JsonObject也支持通过Json字符串或者用addpProperty()方法（相当于前面JSONObject的put方法）来构建，因为麻烦第二种就不再演示了，大家可以自己去试一下。</li><li>存在JsonObject里的数据称为JsonElement，而JsonElement有四种类型（意思就是说这四个类都是继承于JsonElement的）：JsonPrimitive（相当于number或者string或者boolean)、JsonArray（任意类型的JsonElement的集合，也可以混合类型）、JsonNull（相当于null）、JsonObject（嵌套自己类型），更多的详情请麻烦看下面的例子吧：</li></ol><pre><code>    String json = &quot;{\&quot;name\&quot;:\&quot;Bruce Eckel\&quot;,\&quot;age\&quot;:61,\&quot;male\&quot;:true,\&quot;representative_books\&quot;:[\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;:{\&quot;company\&quot;:\&quot;MindView\&quot;,\&quot;position\&quot;:\&quot;CEO\&quot;},\&quot;comment\&quot;:null}&quot;;    JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject();    System.out.println(jsonObject.getAsJsonPrimitive(&quot;name&quot;));    System.out.println(jsonObject.getAsJsonArray(&quot;representative_books&quot;));    System.out.println(jsonObject.getAsJsonObject(&quot;job&quot;));</code></pre><p>输出效果如下</p><blockquote><p>“Bruce Eckel”<br>[“Thinking in C++”,”Thinking in Java”]<br>{“company”:”MindView”,”position”:”CEO”}</p></blockquote><p>而通过debug以上代码，效果如下图<br><img src="/2018/10/05/gson/images/json_element.png" class="[png]" title="The types of JsonElement"><br>从这里就能很清晰的看到Gson提供的JsonObject的用法和其类型的解释了。可见Gson对于Json数据获取也是比较方便的。</p><hr><h2 id="可见Gson的优势"><a href="#可见Gson的优势" class="headerlink" title="可见Gson的优势"></a>可见Gson的优势</h2><ol><li>解决了null的歧义问题，当序列化的时候，如果对象的某个字段为null，是不会输出到Json字符串中的。当反序列化的时候，某个字段在Json字符串中找不到对应的值，就会被赋值为null。</li><li>自定义类型自动转换，且利用注解能支持字段过滤，支持任意的复杂对象转换。</li><li>代码量明显大幅度减少。</li><li>定义了一套Json数据类型，能够生成可压缩和可读的Json的字符串输出。</li></ol><hr><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在这里已经大致说完org.json和Gson的基本用法和介绍了，但真的仅仅是基本用法，其实Gson还有更多的像自定义Gson配置，各种注解过滤等等，不过对于简单的Json数据转换已经比较足够去应用了。<br>&nbsp;&nbsp;&nbsp;&nbsp;用了Gson之后对比起org.json，肉眼可见的代码量减少，而且在反序列化时对类型也毫无阻碍，不用换来换去。但是单纯是这一点点使用例子与介绍的话实际上很难完全展示出Gson全部魅力，这也仅仅只是冰山一角。有机会的话会试着写更多Gson的用法吧。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.json.org/" target="_blank" rel="noopener">ABOUT JSON</a></li><li><a href="https://stleary.github.io/JSON-java/" target="_blank" rel="noopener">org.json DOCUMENT</a></li><li><a href="https://blog.csdn.net/u013075699/article/details/77964344" target="_blank" rel="noopener">JSONOBJECT NULL SOLUTION</a></li><li><a href="https://github.com/google/gson/blob/master/UserGuide.md" target="_blank" rel="noopener">GSON USER GUIDE</a></li><li><a href="http://tool.oschina.net/apidocs/apidoc?api=gson2.2.2" target="_blank" rel="noopener">GSON DOCUMENT</a></li><li><a href="https://blog.csdn.net/vickyway/article/details/48157819" target="_blank" rel="noopener">COMPARISON AMONG JSON LIBRARY</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Welcome to White Noise</title>
      <link href="/2018/09/28/white-noise/"/>
      <url>/2018/09/28/white-noise/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;Welcome to <a href="https://chitoseyono.github.io/" target="_blank" rel="noopener">White Noise - Chitose Yono Offical Blog</a>! The website is still in constructing and after a while you can enjoy my articles here. Though whether they’re writen in English or Chinese depends on my heart, maybe most of time there is Chinese version.</p><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><h3 id="Todo-list"><a href="#Todo-list" class="headerlink" title="Todo-list"></a>Todo-list</h3><ul><li>Navigator for articles √</li><li>Music bar √</li><li>Original background images for changing √</li><li>Domain binding for the blog √</li><li>Pin to top √</li><li>Gallery</li><li>Categories</li><li>After all of these finished, I’ll make a conclusion.</li></ul><h3 id="Chitose-Yono"><a href="#Chitose-Yono" class="headerlink" title="Chitose Yono"></a>Chitose Yono</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;An undergraduate majoring in Software Programing. Got a lot of interests including music, art, traveling and so on, so don’t expect such a introvert guy will fill the blog with barely programing.</p><h3 id="White-Noise"><a href="#White-Noise" class="headerlink" title="White Noise"></a>White Noise</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Article in <a href="https://chitoseyono.github.io/" target="_blank" rel="noopener">White Noise</a> will be include but not limited to</p><ul><li>Software programing</li><li>Music making</li><li>Vomit machine</li></ul><h3 id="Vomit-machine"><a href="#Vomit-machine" class="headerlink" title="Vomit machine"></a>Vomit machine</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;To talk about the surrounding naraku everyday just like vomitting the shit, so you may have to taste the fucking emotional words in it.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
