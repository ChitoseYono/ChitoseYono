<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Json和Gson的介绍与简单使用</title>
      <link href="/2018/10/05/gson/"/>
      <url>/2018/10/05/gson/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。<br>&nbsp;&nbsp;&nbsp;&nbsp;Gson（又称Google Json）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Json的使用大部分人都会知道的一个轻量级库：<a href="https://github.com/stleary/JSON-java" target="_blank" rel="noopener">org.json</a>，现在仍旧有不少人用，不过他对于json格式到bean格式的转换设计的有缺陷而且麻烦（例如复杂类型转换），对于简单的Json序列化操作时如此<strong>轻量级</strong>的类库是个不错的选择。（毕竟轻量级且五脏俱全）<br>&nbsp;&nbsp;&nbsp;&nbsp;如今对于Json的类库比较广为人知的有<a href="http://json-lib.sourceforge.net/index.html" target="_blank" rel="noopener">json-lib</a>、Jackson、阿里巴巴的 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">FastJson</a>、谷歌的 <a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>，json-lib依赖的包太多速度也慢就不提了，虽然FastJson在parseJson有算法上的先进性以至能大大提高其速度运作，而Jackson在速度上也相差不多，但Gson在对于复杂的类型转换上有更强的性能，对于标准化的类库来说，Gson更能被称为Json的神器，那么在本篇我会写关于org.json的简单使用与Gson的常见使用来比较两者的用途与用法。<br>&nbsp;&nbsp;&nbsp;&nbsp;本章代码已上传到<a href="https://github.com/ChitoseYono/JsonTest" target="_blank" rel="noopener">github</a>，可以查看代码自己研究。</p><hr><h2 id="添加类库依赖"><a href="#添加类库依赖" class="headerlink" title="添加类库依赖"></a><strong>添加类库依赖</strong></h2><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><p><strong>org.json</strong>:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.json&lt;/groupId&gt;    &lt;artifactId&gt;json&lt;/artifactId&gt;    &lt;version&gt;20180813&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>Gson</strong>:</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;  &lt;artifactId&gt;gson&lt;/artifactId&gt;  &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a><strong>Gradle</strong></h3><p><strong>org.json</strong>:</p><pre><code>compile group: &#39;org.json&#39;, name: &#39;json&#39;, version: &#39;20180813&#39;</code></pre><p><strong>Gson</strong>:</p><pre><code>dependencies {  implementation &#39;com.google.code.gson:gson:2.8.5&#39;}</code></pre><hr><h2 id="Json数据与Bean"><a href="#Json数据与Bean" class="headerlink" title="Json数据与Bean"></a><strong>Json数据与Bean</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在正式介绍前简单看看本章会用到的Json数据与相应的JavaBean：</p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a><strong>Json</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Json数据例子中简单地囊括Json中所有的类型，包括字符串型(string)，数字型(number)，布尔型(true/false)，空型(null)和object型。</p><pre><code>{    &quot;name&quot;: &quot;Bruce Eckel&quot;,    &quot;age&quot;: 61,    &quot;male&quot;: true,    &quot;representative_books&quot;: [        &quot;Thinking in C++&quot;,        &quot;Thinking in Java&quot;    ],    &quot;job&quot;: {        &quot;company&quot;: &quot;MindView&quot;,        &quot;position&quot;: &quot;CEO&quot;    },    &quot;comment&quot;: null}</code></pre><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a><strong>JavaBean</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其中设置了books和representive_works有不同的key，来考察类库的兼容性。而且comment在这不当做属性，只当做返回json数据中的备注。</p><pre><code>public class Person {    String name;    int age;    boolean male;    String[] books;    Job job;    //构造方法，getter,setter省略}class Job {    String company;    String position;    //构造方法，getter,setter省略}</code></pre><hr><h2 id="org-json"><a href="#org-json" class="headerlink" title="org.json"></a><strong>org.json</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;先简单说说org.json的用法吧，他提供的类库十分简单，只有四个常用类一个异常类，其中最为常用的一个类就JSONObject，基本可以用这个类解决比较多的事，org.json的设定是将它里面的类用作存储功能。<br><img src="/2018/10/05/gson/images/json_doucment.jpg" alt="org.json&#39;s document"></p><h3 id="获取Json格式数据"><a href="#获取Json格式数据" class="headerlink" title="获取Json格式数据"></a><strong>获取Json格式数据</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其实利用org.json基本上就像是Map&lt;K,V&gt;一样取值存值而已。</p><p>JSONObject有几个常用的构造方法，那么我先使用JSONObject来进行序列化：</p><pre><code>    //字符串转Json    String jsonStr = &quot;{\&quot;name\&quot;: \&quot;Bruce Eckel\&quot;,\&quot;age\&quot;: 61,\&quot;male\&quot;: true,\&quot;representative_books\&quot;: [\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;: {\&quot;company\&quot;: \&quot;MindView\&quot;,\&quot;position\&quot;: \&quot;CEO\&quot;},\&quot;comment\&quot;: null}&quot;;    JSONObject strJson =new JSONObject(jsonStr);    //传入Json格式字符串    System.out.println(&quot;构造参数为String类：&quot;+strJson);    //Map转Json    Map&lt;String,Object&gt; jsonMap = new HashMap&lt;String,Object&gt;();    jsonMap.put(&quot;name&quot;, &quot;Bruce Eckel&quot;);    jsonMap.put(&quot;age&quot;, 61);    jsonMap.put(&quot;male&quot;, true);    jsonMap.put(&quot;job&quot;, new JSONObject(&quot;{\&quot;company\&quot;: \&quot;MindView\&quot;, \&quot;position\&quot;: \&quot;CEO\&quot;}&quot;));    jsonMap.put(&quot;representative_books&quot;, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;});    jsonMap.put(&quot;comment&quot;,null);    JSONObject mapJson = new JSONObject(jsonMap);   //传入Map类型              System.out.println(&quot;构造参数为Map类：&quot;  + mapJson);    //JavaBean转Json    Person bruce = new Person(&quot;Bruce Eckel&quot;, 61, true, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;} , new Job(&quot;MindView&quot;, &quot;CEO&quot;));    JSONObject beanJson = new JSONObject(bruce);    //传入Bean类型        System.out.println(&quot;构造参数为Bean类：&quot; + beanJson);    //用无参构造方法传参数的方式    JSONObject jsonObject = new JSONObject();   //无参构造器    jsonObject.put(&quot;name&quot;,&quot;Bruce Eckel&quot;);    jsonObject.put(&quot;age&quot;, 61);    jsonObject.put(&quot;male&quot;, true);    jsonObject.put(&quot;job&quot;, new JSONObject(&quot;{\&quot;company\&quot;: \&quot;MindView\&quot;, \&quot;position\&quot;: \&quot;CEO\&quot;}&quot;));  //此处用的是JSONObject    jsonObject.put(&quot;representative_books&quot;, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;});    jsonObject.put(&quot;comment&quot;, &quot;null&quot;);          //此处输入的是&quot;null&quot;    System.out.println(&quot;构造参数为空：&quot;+jsonObject);</code></pre><p>输出效果如下：</p><blockquote><p>构造参数为String类：{“name”:”Bruce Eckel”,”comment”:null,”representive_works”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><blockquote><p>构造参数为Map类：{“name”:”Bruce Eckel”,”representive_work”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><blockquote><p>构造参数为Bean类：{“books”:[“Thinking in C++”,”Thinking in Java”],”gender”:true,”name”:”Bruce Eckel”,”job”:{},”age”:61}</p></blockquote><blockquote><p>构造参数为空：{“representive_work”:[“Thinking in C++”,”Thinking in Java”],”name”:”Bruce Eckel”,”comment”:”null”,”job”:{“company”:”MindView”,”position”:”CEO”},”age”:61,”male”:true}</p></blockquote><p><strong>可见JSONObject来进行序列化有如下几点缺陷</strong>：</p><ol><li>得到的Json数据是无序的；</li><li>无论是Map还是JSONObject的put()方法都没办法直接放null值否则会被省略不作序列化；</li><li>JavaBean中的自定义类型属性无法被序列化。</li></ol><p><strong>对于第一点的解决方法</strong>：<br>org.json提供了一个有序的类JSONStringer，用法如下</p><pre><code>    JSONStringer jsonStringer = new JSONStringer();    jsonStringer.object();        jsonStringer.key(&quot;name&quot;);        jsonStringer.value(&quot;Bruce Eckel&quot;);        jsonStringer.key(&quot;age&quot;);        jsonStringer.value(61);        jsonStringer.key(&quot;male&quot;);        jsonStringer.value(true);;        jsonStringer.key(&quot;job&quot;);        jsonStringer.object();            jsonStringer.key(&quot;company&quot;);            jsonStringer.value(&quot;MindView&quot;);            jsonStringer.key(&quot;position&quot;);            jsonStringer.value(&quot;CEO&quot;);        jsonStringer.endObject();        jsonStringer.key(&quot;representative_works&quot;);        jsonStringer.array();            jsonStringer.value(&quot;Thinking in C++&quot;);            jsonStringer.value(&quot;Thinking in Java&quot;);        jsonStringer.endArray();        jsonStringer.key(&quot;comment&quot;);        jsonStringer.value(&quot;null&quot;);    jsonStringer.endObject();    System.out.println(jsonStringer.toString());</code></pre><p>输出效果如下</p><blockquote><p>{“name”:”Bruce Eckel”,”age”:61,”male”:true,”job”:{“company”:”MindView”,”position”:”CEO”},”representative_works”:[“Thinking in C++”,”Thinking in Java”],”comment”:”null”}</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然是麻烦了点(非常麻烦)…毕竟他是有序的。而且一般情况用JSONObject也是够的因为有序不一定有用，而且JSONStringer虽然较为麻烦，但是他对于多重嵌套的问题有很大帮助。但要注意object()和endObject()、array()和endArray()，一定要匹配，否则就会抛出JSONException异常。</p><p><strong>对于第二点的解决方法</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;JSONObject对于null的识别是有坑的，想要赋予值为空的属性时得以”null”的方式传入（可以参考上述无参的构造方式中传”null”的方法-第29行。）<br>那么问题来了，如果想传值为”null”的字符串怎么办？<br>那可能只能通过直接处理字符串的方式了：</p><pre><code>    jsonObject.toString.replaceAll(&quot;:null,&quot;, &quot;:\&quot;null\&quot;,&quot;) </code></pre><p><strong>对于第三点的解决方法</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;org.json库无法识别自定义属性，所以只好用嵌套的方式，即JSONObject里包含JSONObject的方式来代替。（可以参考上述无参构造方式中的job-第27行)</p><h3 id="获取Json的属性值"><a href="#获取Json的属性值" class="headerlink" title="获取Json的属性值"></a><strong>获取Json的属性值</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这里用回之前的JSONObject。org.json压根就没做反序列化，如果手动来做的话这样是比较快的方法了，如果不是为了演示用法真不想做一次，对比起任何一个类库即使是json-lib都比他方便多了。当然，如果你只是为了取得里面的部分数据绝对是可以使用org.json的。</p><pre><code>    String jsonStr = &quot;{\&quot;name\&quot;: \&quot;Bruce Eckel\&quot;,\&quot;age\&quot;: 61,\&quot;male\&quot;: true,\&quot;representive_works\&quot;: [\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;: {\&quot;company\&quot;: \&quot;MindView\&quot;,\&quot;position\&quot;: \&quot;CEO\&quot;},\&quot;comment\&quot;: null}&quot;;    JSONObject strJson =new JSONObject(jsonStr);    // 传入字符串    JSONArray jsonArray = strJson.getJSONArray(&quot;representive_works&quot;);    List&lt;String&gt; lists = new ArrayList&lt;String&gt;();    for (int i = 0; i &lt; jsonArray.length(); i++) {        lists.add(i,jsonArray.optString(i));    }    String[] books = new String[2];    lists.toArray(books);    Job job = new Job(strJson.getJSONObject(&quot;job&quot;).getString(&quot;company&quot;), strJson.getJSONObject(&quot;job&quot;).getString(&quot;position&quot;));    Person bruce = new Person(strJson.getString(&quot;name&quot;),strJson.getInt(&quot;age&quot;),strJson.getBoolean(&quot;male&quot;), books, job);    System.out.println(bruce.name+&quot; &quot;+bruce.age+&quot; &quot;+bruce.male+&quot; &quot;+bruce.books[0]+&quot; &quot;+bruce.books[1]+&quot; &quot;+bruce.job.company+&quot; &quot;+bruce.job.position);</code></pre><p>输出效果如下</p><blockquote><p>Bruce Eckel 61 true Thinking in C++ Thinking in Java MindView CEO</p></blockquote><p>以上就是基本的org.json类库的使用方法了，当然还有像JsonTokener和JSONWritter之类的类，都是没什么必要的，基本用JSONObject、JSONStringer、JSONArray这几个类可以完成业务。这也是org.json轻便之处，如果只是少量的Json操作，那用org.json这种轻量级类库再适合不过了。</p><hr><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a><strong>Gson</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Gson中最重要的类可能就是Gson类了，但Gson中是不像其他类那样以JSONObject这样像Map一样的类存储数据的，Gson相当于只为了使用其成员方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;在操作之前，记得前面设计数据key和JavaBean属性时名字有不同的吗？序列化时如果不作任何操作只会用回原来属性名，而Gson给出了用注解的方式来处理的方法：</p><pre><code>    @SerializedName(value = &quot;representative_books&quot;)</code></pre><p><img src="/2018/10/05/gson/images/json_anno.png" alt="Annotation to change SerializedName "><br>&nbsp;&nbsp;&nbsp;&nbsp;那么在序列化时就会给他自动命名为”representative_books”，反序列化的时候就自动识别key为”representative_books”的语句</p><hr><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h3><p><em>序列化就是将JavaBean到Json字符串的过程</em></p><pre><code>        Person bruce = new Person(&quot;Bruce Eckel&quot;, 61, true, new String[]{ &quot;Thinking in C++&quot;,&quot;Thinking in Java&quot;} , new Job(&quot;MindView&quot;, &quot;CEO&quot;));        Gson gson = new Gson();        String json = gson.toJson(bruce);        System.out.println(json);</code></pre><p>输出效果</p><blockquote><p>{“name”:”Bruce Eckel”,”age”:61,”male”:true,”representative_books”:[“Thinking in C++”,”Thinking in Java”],”job”:{“company”:”MindView”,”position”:”CEO”}}</p></blockquote><hr><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><strong>反序列化</strong></h3><p><em>反序列化就是将字符串转换成JavaBean的过程</em></p><pre><code>        Gson gson = new Gson();        String json = &quot;{\&quot;name\&quot;:\&quot;Bruce Eckel\&quot;,\&quot;age\&quot;:61,\&quot;male\&quot;:true,\&quot;representative_books\&quot;:[\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;:{\&quot;company\&quot;:\&quot;MindView\&quot;,\&quot;position\&quot;:\&quot;CEO\&quot;},\&quot;comment\&quot;:null}&quot;;        Person bruce = gson.fromJson(json, Person.class);        System.out.println(bruce.getName()+&quot; &quot;+bruce.getAge()+&quot; &quot;+bruce.isMale()+&quot; &quot;+bruce.getBooks()[0]+&quot; &quot;+bruce.getBooks()[1]+&quot; &quot;+bruce.getJob().company+&quot; &quot;+bruce.getJob().position);</code></pre><p>输出效果</p><blockquote><p>Bruce Eckel 61 true Thinking in C++ Thinking in Java MindView CEO</p></blockquote><hr><h3 id="获取Json数据"><a href="#获取Json数据" class="headerlink" title="获取Json数据"></a><strong>获取Json数据</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;看到这里可能就会说，org.json的前面两点实际上跟Gson的序列化反序列化不太一样吧，org.json是获取数据，Gson是直接序列化了，那如果我只是要获取数据Gson还得创一个JavaBean不更加麻烦吗？实际上是不一定要JavaBean的，相信谷歌设计者也不会这么蠢。<br>&nbsp;&nbsp;&nbsp;&nbsp;Gson作为Json的神器，也有一套类似的方法。但此前先说一些概念性的东西：</p><ol><li>Gson中也有一个叫JsonObject的类，跟之前org.json无论是名字（前面的是JSONObject）还是用处都很像（都是用来存储数据），但还是有不一样的地方。</li><li>Gson的JsonObject也支持通过Json字符串或者用addpProperty()方法（相当于前面JSONObject的put方法）来构建，因为麻烦第二种就不再演示了，大家可以自己去试一下。</li><li>存在JsonObject里的数据称为JsonElement，而JsonElement有四种类型（意思就是说这四个类都是继承于JsonElement的）：JsonPrimitive（相当于number或者string或者boolean)、JsonArray（任意类型的JsonElement的集合，也可以混合类型）、JsonNull（相当于null）、JsonObject（嵌套自己类型），更多的详情请麻烦看下面的例子吧：</li></ol><pre><code>    String json = &quot;{\&quot;name\&quot;:\&quot;Bruce Eckel\&quot;,\&quot;age\&quot;:61,\&quot;male\&quot;:true,\&quot;representative_books\&quot;:[\&quot;Thinking in C++\&quot;,\&quot;Thinking in Java\&quot;],\&quot;job\&quot;:{\&quot;company\&quot;:\&quot;MindView\&quot;,\&quot;position\&quot;:\&quot;CEO\&quot;},\&quot;comment\&quot;:null}&quot;;    JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject();    System.out.println(jsonObject.getAsJsonPrimitive(&quot;name&quot;));    System.out.println(jsonObject.getAsJsonArray(&quot;representative_books&quot;));    System.out.println(jsonObject.getAsJsonObject(&quot;job&quot;));</code></pre><p>输出效果如下</p><blockquote><p>“Bruce Eckel”<br>[“Thinking in C++”,”Thinking in Java”]<br>{“company”:”MindView”,”position”:”CEO”}</p></blockquote><p>而通过debug以上代码，效果如下图<br><img src="/2018/10/05/gson/images/json_element.png" class="[png]" title="The types of JsonElement"><br>从这里就能很清晰的看到Gson提供的JsonObject的用法和其类型的解释了。可见Gson对于Json数据获取也是比较方便的。</p><hr><h2 id="可见Gson的优势"><a href="#可见Gson的优势" class="headerlink" title="可见Gson的优势"></a>可见Gson的优势</h2><ol><li>解决了null的歧义问题，当序列化的时候，如果对象的某个字段为null，是不会输出到Json字符串中的。当反序列化的时候，某个字段在Json字符串中找不到对应的值，就会被赋值为null。</li><li>自定义类型自动转换，且利用注解能支持字段过滤，支持任意的复杂对象转换。</li><li>代码量明显大幅度减少。</li><li>定义了一套Json数据类型，能够生成可压缩和可读的Json的字符串输出。</li></ol><hr><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在这里已经大致说完org.json和Gson的基本用法和介绍了，但真的仅仅是基本用法，其实Gson还有更多的像自定义Gson配置，各种注解过滤等等，不过对于简单的Json数据转换已经比较足够去应用了。<br>&nbsp;&nbsp;&nbsp;&nbsp;用了Gson之后对比起org.json，肉眼可见的代码量减少，而且在反序列化时对类型也毫无阻碍，不用换来换去。但是单纯是这一点点使用例子与介绍的话实际上很难完全展示出Gson全部魅力，这也仅仅只是冰山一角。有机会的话会试着写更多Gson的用法吧。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.json.org/" target="_blank" rel="noopener">ABOUT JSON</a></li><li><a href="https://stleary.github.io/JSON-java/" target="_blank" rel="noopener">org.json DOCUMENT</a></li><li><a href="https://blog.csdn.net/u013075699/article/details/77964344" target="_blank" rel="noopener">JSONOBJECT NULL SOLUTION</a></li><li><a href="https://github.com/google/gson/blob/master/UserGuide.md" target="_blank" rel="noopener">GSON USER GUIDE</a></li><li><a href="http://tool.oschina.net/apidocs/apidoc?api=gson2.2.2" target="_blank" rel="noopener">GSON DOCUMENT</a></li><li><a href="https://blog.csdn.net/vickyway/article/details/48157819" target="_blank" rel="noopener">COMPARISON AMONG JSON LIBRARY</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Welcome to White Noise</title>
      <link href="/2018/09/28/white-noise/"/>
      <url>/2018/09/28/white-noise/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;&nbsp;&nbsp;Welcome to <a href="https://chitoseyono.github.io/" target="_blank" rel="noopener">White Noise - Chitose Yono Offical Blog</a>! The website is still in constructing and after a while you can enjoy my articles here. Though whether they’re writen in English or Chinese depends on my heart, maybe most of time there is Chinese version.</p><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><h3 id="Todo-list"><a href="#Todo-list" class="headerlink" title="Todo-list"></a>Todo-list</h3><ul><li>Navigator for articles √</li><li>Music bar √</li><li>Original background images for changing √</li><li>Domain binding for the blog √</li><li>Gallery</li><li>Categories</li><li>After all of these finished, I’ll make a conclusion.</li></ul><h3 id="Chitose-Yono"><a href="#Chitose-Yono" class="headerlink" title="Chitose Yono"></a>Chitose Yono</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;An undergraduate majoring in Software Programing. Got a lot of interests including music, art, traveling and so on, so don’t expect such a introvert guy will fill the blog with barely programing.</p><h3 id="White-Noise"><a href="#White-Noise" class="headerlink" title="White Noise"></a>White Noise</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Article in <a href="https://chitoseyono.github.io/" target="_blank" rel="noopener">White Noise</a> will be include but not limited to</p><ul><li>Software programing</li><li>Music making</li><li>Vomit machine</li></ul><h3 id="Vomit-machine"><a href="#Vomit-machine" class="headerlink" title="Vomit machine"></a>Vomit machine</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;To talk about the surrounding naraku everyday just like vomitting the shit, so you may have to taste the fucking emotional words in it.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
